/*
MetaFab API

 Complete MetaFab API references and guides can be found at: https://trymetafab.com

API version: 1.4.1
Contact: metafabproject@gmail.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package metafab

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// ItemsApiService ItemsApi service
type ItemsApiService service

type ApiBatchMintCollectionItemsRequest struct {
	ctx context.Context
	ApiService *ItemsApiService
	collectionId string
	xAuthorization *string
	xPassword *string
	batchMintCollectionItemsRequest *BatchMintCollectionItemsRequest
}

// The &#x60;secretKey&#x60; of the authenticating game.
func (r ApiBatchMintCollectionItemsRequest) XAuthorization(xAuthorization string) ApiBatchMintCollectionItemsRequest {
	r.xAuthorization = &xAuthorization
	return r
}

// The password of the authenticating game. Required to decrypt and perform blockchain transactions with the game primary wallet.
func (r ApiBatchMintCollectionItemsRequest) XPassword(xPassword string) ApiBatchMintCollectionItemsRequest {
	r.xPassword = &xPassword
	return r
}

func (r ApiBatchMintCollectionItemsRequest) BatchMintCollectionItemsRequest(batchMintCollectionItemsRequest BatchMintCollectionItemsRequest) ApiBatchMintCollectionItemsRequest {
	r.batchMintCollectionItemsRequest = &batchMintCollectionItemsRequest
	return r
}

func (r ApiBatchMintCollectionItemsRequest) Execute() (*TransactionModel, *http.Response, error) {
	return r.ApiService.BatchMintCollectionItemsExecute(r)
}

/*
BatchMintCollectionItems Batch mint collection items

Creates (mints) the provided itemIds of the specified quantities to the provided wallet address or wallet address associated with the provided walletId.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param collectionId Any collection id within the MetaFab ecosystem.
 @return ApiBatchMintCollectionItemsRequest
*/
func (a *ItemsApiService) BatchMintCollectionItems(ctx context.Context, collectionId string) ApiBatchMintCollectionItemsRequest {
	return ApiBatchMintCollectionItemsRequest{
		ApiService: a,
		ctx: ctx,
		collectionId: collectionId,
	}
}

// Execute executes the request
//  @return TransactionModel
func (a *ItemsApiService) BatchMintCollectionItemsExecute(r ApiBatchMintCollectionItemsRequest) (*TransactionModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemsApiService.BatchMintCollectionItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/collections/{collectionId}/batchMints"
	localVarPath = strings.Replace(localVarPath, "{"+"collectionId"+"}", url.PathEscape(parameterToString(r.collectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthorization == nil {
		return localVarReturnValue, nil, reportError("xAuthorization is required and must be specified")
	}
	if r.xPassword == nil {
		return localVarReturnValue, nil, reportError("xPassword is required and must be specified")
	}
	if r.batchMintCollectionItemsRequest == nil {
		return localVarReturnValue, nil, reportError("batchMintCollectionItemsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-Authorization"] = parameterToString(*r.xAuthorization, "")
	localVarHeaderParams["X-Password"] = parameterToString(*r.xPassword, "")
	// body params
	localVarPostBody = r.batchMintCollectionItemsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBatchTransferCollectionItemsRequest struct {
	ctx context.Context
	ApiService *ItemsApiService
	collectionId string
	xAuthorization *string
	xPassword *string
	batchTransferCollectionItemsRequest *BatchTransferCollectionItemsRequest
}

// The &#x60;secretKey&#x60; of a specific game or the &#x60;accessToken&#x60; of a specific player.
func (r ApiBatchTransferCollectionItemsRequest) XAuthorization(xAuthorization string) ApiBatchTransferCollectionItemsRequest {
	r.xAuthorization = &xAuthorization
	return r
}

// The password of the authenticating game or player. Required to decrypt and perform blockchain transactions with the game or player primary wallet.
func (r ApiBatchTransferCollectionItemsRequest) XPassword(xPassword string) ApiBatchTransferCollectionItemsRequest {
	r.xPassword = &xPassword
	return r
}

func (r ApiBatchTransferCollectionItemsRequest) BatchTransferCollectionItemsRequest(batchTransferCollectionItemsRequest BatchTransferCollectionItemsRequest) ApiBatchTransferCollectionItemsRequest {
	r.batchTransferCollectionItemsRequest = &batchTransferCollectionItemsRequest
	return r
}

func (r ApiBatchTransferCollectionItemsRequest) Execute() (*TransactionModel, *http.Response, error) {
	return r.ApiService.BatchTransferCollectionItemsExecute(r)
}

/*
BatchTransferCollectionItems Batch transfer collection items

Transfers one or multiple items of specified quantities to the provided wallet addresses or wallet addresses associated with the provided walletIds. You may also provide a combination of addresses and walletIds in one request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param collectionId Any collection id within the MetaFab ecosystem.
 @return ApiBatchTransferCollectionItemsRequest
*/
func (a *ItemsApiService) BatchTransferCollectionItems(ctx context.Context, collectionId string) ApiBatchTransferCollectionItemsRequest {
	return ApiBatchTransferCollectionItemsRequest{
		ApiService: a,
		ctx: ctx,
		collectionId: collectionId,
	}
}

// Execute executes the request
//  @return TransactionModel
func (a *ItemsApiService) BatchTransferCollectionItemsExecute(r ApiBatchTransferCollectionItemsRequest) (*TransactionModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemsApiService.BatchTransferCollectionItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/collections/{collectionId}/batchTransfers"
	localVarPath = strings.Replace(localVarPath, "{"+"collectionId"+"}", url.PathEscape(parameterToString(r.collectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthorization == nil {
		return localVarReturnValue, nil, reportError("xAuthorization is required and must be specified")
	}
	if r.xPassword == nil {
		return localVarReturnValue, nil, reportError("xPassword is required and must be specified")
	}
	if r.batchTransferCollectionItemsRequest == nil {
		return localVarReturnValue, nil, reportError("batchTransferCollectionItemsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-Authorization"] = parameterToString(*r.xAuthorization, "")
	localVarHeaderParams["X-Password"] = parameterToString(*r.xPassword, "")
	// body params
	localVarPostBody = r.batchTransferCollectionItemsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBurnCollectionItemRequest struct {
	ctx context.Context
	ApiService *ItemsApiService
	collectionId string
	collectionItemId float32
	xAuthorization *string
	xPassword *string
	burnCollectionItemRequest *BurnCollectionItemRequest
}

// The &#x60;secretKey&#x60; of a specific game or the &#x60;accessToken&#x60; of a specific player.
func (r ApiBurnCollectionItemRequest) XAuthorization(xAuthorization string) ApiBurnCollectionItemRequest {
	r.xAuthorization = &xAuthorization
	return r
}

// The password of the authenticating game or player. Required to decrypt and perform blockchain transactions with the game or player primary wallet.
func (r ApiBurnCollectionItemRequest) XPassword(xPassword string) ApiBurnCollectionItemRequest {
	r.xPassword = &xPassword
	return r
}

func (r ApiBurnCollectionItemRequest) BurnCollectionItemRequest(burnCollectionItemRequest BurnCollectionItemRequest) ApiBurnCollectionItemRequest {
	r.burnCollectionItemRequest = &burnCollectionItemRequest
	return r
}

func (r ApiBurnCollectionItemRequest) Execute() (*TransactionModel, *http.Response, error) {
	return r.ApiService.BurnCollectionItemExecute(r)
}

/*
BurnCollectionItem Burn collection item

Removes (burns) the provided quantity of the collectionItemId from the authenticating game or players wallet. The quantity is permanently removed from the circulating supply of the item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param collectionId Any collection id within the MetaFab ecosystem.
 @param collectionItemId Any item id for the collection. Zero, or a positive integer.
 @return ApiBurnCollectionItemRequest
*/
func (a *ItemsApiService) BurnCollectionItem(ctx context.Context, collectionId string, collectionItemId float32) ApiBurnCollectionItemRequest {
	return ApiBurnCollectionItemRequest{
		ApiService: a,
		ctx: ctx,
		collectionId: collectionId,
		collectionItemId: collectionItemId,
	}
}

// Execute executes the request
//  @return TransactionModel
func (a *ItemsApiService) BurnCollectionItemExecute(r ApiBurnCollectionItemRequest) (*TransactionModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemsApiService.BurnCollectionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/collections/{collectionId}/items/{collectionItemId}/burns"
	localVarPath = strings.Replace(localVarPath, "{"+"collectionId"+"}", url.PathEscape(parameterToString(r.collectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"collectionItemId"+"}", url.PathEscape(parameterToString(r.collectionItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthorization == nil {
		return localVarReturnValue, nil, reportError("xAuthorization is required and must be specified")
	}
	if r.xPassword == nil {
		return localVarReturnValue, nil, reportError("xPassword is required and must be specified")
	}
	if r.burnCollectionItemRequest == nil {
		return localVarReturnValue, nil, reportError("burnCollectionItemRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-Authorization"] = parameterToString(*r.xAuthorization, "")
	localVarHeaderParams["X-Password"] = parameterToString(*r.xPassword, "")
	// body params
	localVarPostBody = r.burnCollectionItemRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCollectionRequest struct {
	ctx context.Context
	ApiService *ItemsApiService
	xAuthorization *string
	xPassword *string
	createCollectionRequest *CreateCollectionRequest
}

// The &#x60;secretKey&#x60; of the authenticating game.
func (r ApiCreateCollectionRequest) XAuthorization(xAuthorization string) ApiCreateCollectionRequest {
	r.xAuthorization = &xAuthorization
	return r
}

// The password of the authenticating game. Required to decrypt and perform blockchain transactions with the game primary wallet.
func (r ApiCreateCollectionRequest) XPassword(xPassword string) ApiCreateCollectionRequest {
	r.xPassword = &xPassword
	return r
}

func (r ApiCreateCollectionRequest) CreateCollectionRequest(createCollectionRequest CreateCollectionRequest) ApiCreateCollectionRequest {
	r.createCollectionRequest = &createCollectionRequest
	return r
}

func (r ApiCreateCollectionRequest) Execute() (*CreateCollection200Response, *http.Response, error) {
	return r.ApiService.CreateCollectionExecute(r)
}

/*
CreateCollection Create collection

Creates a new game item collection and deploys an extended functionality ERC1155 contract on behalf of the authenticating game's primary wallet. The deployed ERC1155 contract is preconfigured to fully support creating unique item types, item transfer timelocks, custom metadata per item, gasless transactions from player managed wallets, and much more.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateCollectionRequest
*/
func (a *ItemsApiService) CreateCollection(ctx context.Context) ApiCreateCollectionRequest {
	return ApiCreateCollectionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateCollection200Response
func (a *ItemsApiService) CreateCollectionExecute(r ApiCreateCollectionRequest) (*CreateCollection200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateCollection200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemsApiService.CreateCollection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/collections"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthorization == nil {
		return localVarReturnValue, nil, reportError("xAuthorization is required and must be specified")
	}
	if r.xPassword == nil {
		return localVarReturnValue, nil, reportError("xPassword is required and must be specified")
	}
	if r.createCollectionRequest == nil {
		return localVarReturnValue, nil, reportError("createCollectionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-Authorization"] = parameterToString(*r.xAuthorization, "")
	localVarHeaderParams["X-Password"] = parameterToString(*r.xPassword, "")
	// body params
	localVarPostBody = r.createCollectionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCollectionItemRequest struct {
	ctx context.Context
	ApiService *ItemsApiService
	collectionId string
	xAuthorization *string
	xPassword *string
	createCollectionItemRequest *CreateCollectionItemRequest
}

// The &#x60;secretKey&#x60; of the authenticating game.
func (r ApiCreateCollectionItemRequest) XAuthorization(xAuthorization string) ApiCreateCollectionItemRequest {
	r.xAuthorization = &xAuthorization
	return r
}

// The password of the authenticating game. Required to decrypt and perform blockchain transactions with the game primary wallet.
func (r ApiCreateCollectionItemRequest) XPassword(xPassword string) ApiCreateCollectionItemRequest {
	r.xPassword = &xPassword
	return r
}

func (r ApiCreateCollectionItemRequest) CreateCollectionItemRequest(createCollectionItemRequest CreateCollectionItemRequest) ApiCreateCollectionItemRequest {
	r.createCollectionItemRequest = &createCollectionItemRequest
	return r
}

func (r ApiCreateCollectionItemRequest) Execute() (*TransactionModel, *http.Response, error) {
	return r.ApiService.CreateCollectionItemExecute(r)
}

/*
CreateCollectionItem Create collection item

Creates a new item type. Item type creation associates all of the relevant item data to a specific itemId. Such as item name, image, description, attributes, any arbitrary data such as 2D or 3D model resolver URLs, and more. It is recommended, but not required, that you create a new item type through this endpoint before minting any quantity of the related itemId.

Any itemId provided will have its existing item type overriden if it already exists.

Item type data is uploaded to, and resolved through IPFS for decentralized persistence.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param collectionId Any collection id within the MetaFab ecosystem.
 @return ApiCreateCollectionItemRequest
*/
func (a *ItemsApiService) CreateCollectionItem(ctx context.Context, collectionId string) ApiCreateCollectionItemRequest {
	return ApiCreateCollectionItemRequest{
		ApiService: a,
		ctx: ctx,
		collectionId: collectionId,
	}
}

// Execute executes the request
//  @return TransactionModel
func (a *ItemsApiService) CreateCollectionItemExecute(r ApiCreateCollectionItemRequest) (*TransactionModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemsApiService.CreateCollectionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/collections/{collectionId}/items"
	localVarPath = strings.Replace(localVarPath, "{"+"collectionId"+"}", url.PathEscape(parameterToString(r.collectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthorization == nil {
		return localVarReturnValue, nil, reportError("xAuthorization is required and must be specified")
	}
	if r.xPassword == nil {
		return localVarReturnValue, nil, reportError("xPassword is required and must be specified")
	}
	if r.createCollectionItemRequest == nil {
		return localVarReturnValue, nil, reportError("createCollectionItemRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-Authorization"] = parameterToString(*r.xAuthorization, "")
	localVarHeaderParams["X-Password"] = parameterToString(*r.xPassword, "")
	// body params
	localVarPostBody = r.createCollectionItemRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCollectionApprovalRequest struct {
	ctx context.Context
	ApiService *ItemsApiService
	collectionId string
	operatorAddress *string
	address *string
	walletId *string
}

// A valid EVM based address. For example, &#x60;0x39cb70F972E0EE920088AeF97Dbe5c6251a9c25D&#x60;.
func (r ApiGetCollectionApprovalRequest) OperatorAddress(operatorAddress string) ApiGetCollectionApprovalRequest {
	r.operatorAddress = &operatorAddress
	return r
}

// A valid EVM based address. For example, &#x60;0x39cb70F972E0EE920088AeF97Dbe5c6251a9c25D&#x60;.
func (r ApiGetCollectionApprovalRequest) Address(address string) ApiGetCollectionApprovalRequest {
	r.address = &address
	return r
}

// Any wallet id within the MetaFab ecosystem.
func (r ApiGetCollectionApprovalRequest) WalletId(walletId string) ApiGetCollectionApprovalRequest {
	r.walletId = &walletId
	return r
}

func (r ApiGetCollectionApprovalRequest) Execute() (bool, *http.Response, error) {
	return r.ApiService.GetCollectionApprovalExecute(r)
}

/*
GetCollectionApproval Get collection approval

Returns a boolean (true/false) representing if the provided operatorAddress has approval to transfer and burn items from the current collection owned by the address or address associated with the provided walletId.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param collectionId Any collection id within the MetaFab ecosystem.
 @return ApiGetCollectionApprovalRequest
*/
func (a *ItemsApiService) GetCollectionApproval(ctx context.Context, collectionId string) ApiGetCollectionApprovalRequest {
	return ApiGetCollectionApprovalRequest{
		ApiService: a,
		ctx: ctx,
		collectionId: collectionId,
	}
}

// Execute executes the request
//  @return bool
func (a *ItemsApiService) GetCollectionApprovalExecute(r ApiGetCollectionApprovalRequest) (bool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemsApiService.GetCollectionApproval")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/collections/{collectionId}/approvals"
	localVarPath = strings.Replace(localVarPath, "{"+"collectionId"+"}", url.PathEscape(parameterToString(r.collectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.operatorAddress == nil {
		return localVarReturnValue, nil, reportError("operatorAddress is required and must be specified")
	}

	localVarQueryParams.Add("operatorAddress", parameterToString(*r.operatorAddress, ""))
	if r.address != nil {
		localVarQueryParams.Add("address", parameterToString(*r.address, ""))
	}
	if r.walletId != nil {
		localVarQueryParams.Add("walletId", parameterToString(*r.walletId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCollectionItemRequest struct {
	ctx context.Context
	ApiService *ItemsApiService
	collectionId string
	collectionItemId float32
}

func (r ApiGetCollectionItemRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCollectionItemExecute(r)
}

/*
GetCollectionItem Get collection item

Returns a metadata object for the provided collectionItemId.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param collectionId Any collection id within the MetaFab ecosystem.
 @param collectionItemId Any item id for the collection. Zero, or a positive integer.
 @return ApiGetCollectionItemRequest
*/
func (a *ItemsApiService) GetCollectionItem(ctx context.Context, collectionId string, collectionItemId float32) ApiGetCollectionItemRequest {
	return ApiGetCollectionItemRequest{
		ApiService: a,
		ctx: ctx,
		collectionId: collectionId,
		collectionItemId: collectionItemId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ItemsApiService) GetCollectionItemExecute(r ApiGetCollectionItemRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemsApiService.GetCollectionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/collections/{collectionId}/items/{collectionItemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"collectionId"+"}", url.PathEscape(parameterToString(r.collectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"collectionItemId"+"}", url.PathEscape(parameterToString(r.collectionItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCollectionItemBalanceRequest struct {
	ctx context.Context
	ApiService *ItemsApiService
	collectionId string
	collectionItemId float32
	address *string
	walletId *string
}

// A valid EVM based address. For example, &#x60;0x39cb70F972E0EE920088AeF97Dbe5c6251a9c25D&#x60;.
func (r ApiGetCollectionItemBalanceRequest) Address(address string) ApiGetCollectionItemBalanceRequest {
	r.address = &address
	return r
}

// Any wallet id within the MetaFab ecosystem.
func (r ApiGetCollectionItemBalanceRequest) WalletId(walletId string) ApiGetCollectionItemBalanceRequest {
	r.walletId = &walletId
	return r
}

func (r ApiGetCollectionItemBalanceRequest) Execute() (int32, *http.Response, error) {
	return r.ApiService.GetCollectionItemBalanceExecute(r)
}

/*
GetCollectionItemBalance Get collection item balance

Returns the current collection item balance of the provided collectionItemId for the provided wallet address or the wallet address associated with the provided walletId.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param collectionId Any collection id within the MetaFab ecosystem.
 @param collectionItemId Any item id for the collection. Zero, or a positive integer.
 @return ApiGetCollectionItemBalanceRequest
*/
func (a *ItemsApiService) GetCollectionItemBalance(ctx context.Context, collectionId string, collectionItemId float32) ApiGetCollectionItemBalanceRequest {
	return ApiGetCollectionItemBalanceRequest{
		ApiService: a,
		ctx: ctx,
		collectionId: collectionId,
		collectionItemId: collectionItemId,
	}
}

// Execute executes the request
//  @return int32
func (a *ItemsApiService) GetCollectionItemBalanceExecute(r ApiGetCollectionItemBalanceRequest) (int32, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemsApiService.GetCollectionItemBalance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/collections/{collectionId}/items/{collectionItemId}/balances"
	localVarPath = strings.Replace(localVarPath, "{"+"collectionId"+"}", url.PathEscape(parameterToString(r.collectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"collectionItemId"+"}", url.PathEscape(parameterToString(r.collectionItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.address != nil {
		localVarQueryParams.Add("address", parameterToString(*r.address, ""))
	}
	if r.walletId != nil {
		localVarQueryParams.Add("walletId", parameterToString(*r.walletId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCollectionItemBalancesRequest struct {
	ctx context.Context
	ApiService *ItemsApiService
	collectionId string
	address *string
	walletId *string
}

// A valid EVM based address. For example, &#x60;0x39cb70F972E0EE920088AeF97Dbe5c6251a9c25D&#x60;.
func (r ApiGetCollectionItemBalancesRequest) Address(address string) ApiGetCollectionItemBalancesRequest {
	r.address = &address
	return r
}

// Any wallet id within the MetaFab ecosystem.
func (r ApiGetCollectionItemBalancesRequest) WalletId(walletId string) ApiGetCollectionItemBalancesRequest {
	r.walletId = &walletId
	return r
}

func (r ApiGetCollectionItemBalancesRequest) Execute() (map[string]int32, *http.Response, error) {
	return r.ApiService.GetCollectionItemBalancesExecute(r)
}

/*
GetCollectionItemBalances Get collection item balances

Returns the current collection item balances of all collection items for the provided wallet address or the wallet address associated with the provided walletId.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param collectionId Any collection id within the MetaFab ecosystem.
 @return ApiGetCollectionItemBalancesRequest
*/
func (a *ItemsApiService) GetCollectionItemBalances(ctx context.Context, collectionId string) ApiGetCollectionItemBalancesRequest {
	return ApiGetCollectionItemBalancesRequest{
		ApiService: a,
		ctx: ctx,
		collectionId: collectionId,
	}
}

// Execute executes the request
//  @return map[string]int32
func (a *ItemsApiService) GetCollectionItemBalancesExecute(r ApiGetCollectionItemBalancesRequest) (map[string]int32, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemsApiService.GetCollectionItemBalances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/collections/{collectionId}/balances"
	localVarPath = strings.Replace(localVarPath, "{"+"collectionId"+"}", url.PathEscape(parameterToString(r.collectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.address != nil {
		localVarQueryParams.Add("address", parameterToString(*r.address, ""))
	}
	if r.walletId != nil {
		localVarQueryParams.Add("walletId", parameterToString(*r.walletId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCollectionItemSuppliesRequest struct {
	ctx context.Context
	ApiService *ItemsApiService
	collectionId string
}

func (r ApiGetCollectionItemSuppliesRequest) Execute() (map[string]int32, *http.Response, error) {
	return r.ApiService.GetCollectionItemSuppliesExecute(r)
}

/*
GetCollectionItemSupplies Get collection item supplies

Returns the currency circulating supply of all collection items.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param collectionId Any collection id within the MetaFab ecosystem.
 @return ApiGetCollectionItemSuppliesRequest
*/
func (a *ItemsApiService) GetCollectionItemSupplies(ctx context.Context, collectionId string) ApiGetCollectionItemSuppliesRequest {
	return ApiGetCollectionItemSuppliesRequest{
		ApiService: a,
		ctx: ctx,
		collectionId: collectionId,
	}
}

// Execute executes the request
//  @return map[string]int32
func (a *ItemsApiService) GetCollectionItemSuppliesExecute(r ApiGetCollectionItemSuppliesRequest) (map[string]int32, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemsApiService.GetCollectionItemSupplies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/collections/{collectionId}/supplies"
	localVarPath = strings.Replace(localVarPath, "{"+"collectionId"+"}", url.PathEscape(parameterToString(r.collectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCollectionItemSupplyRequest struct {
	ctx context.Context
	ApiService *ItemsApiService
	collectionId string
	collectionItemId float32
	address *string
	walletId *string
}

// A valid EVM based address. For example, &#x60;0x39cb70F972E0EE920088AeF97Dbe5c6251a9c25D&#x60;.
func (r ApiGetCollectionItemSupplyRequest) Address(address string) ApiGetCollectionItemSupplyRequest {
	r.address = &address
	return r
}

// Any wallet id within the MetaFab ecosystem.
func (r ApiGetCollectionItemSupplyRequest) WalletId(walletId string) ApiGetCollectionItemSupplyRequest {
	r.walletId = &walletId
	return r
}

func (r ApiGetCollectionItemSupplyRequest) Execute() (int32, *http.Response, error) {
	return r.ApiService.GetCollectionItemSupplyExecute(r)
}

/*
GetCollectionItemSupply Get collection item supply

Returns the current circulating supply of the provided collectionItemId.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param collectionId Any collection id within the MetaFab ecosystem.
 @param collectionItemId Any item id for the collection. Zero, or a positive integer.
 @return ApiGetCollectionItemSupplyRequest
*/
func (a *ItemsApiService) GetCollectionItemSupply(ctx context.Context, collectionId string, collectionItemId float32) ApiGetCollectionItemSupplyRequest {
	return ApiGetCollectionItemSupplyRequest{
		ApiService: a,
		ctx: ctx,
		collectionId: collectionId,
		collectionItemId: collectionItemId,
	}
}

// Execute executes the request
//  @return int32
func (a *ItemsApiService) GetCollectionItemSupplyExecute(r ApiGetCollectionItemSupplyRequest) (int32, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemsApiService.GetCollectionItemSupply")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/collections/{collectionId}/items/{collectionItemId}/supplies"
	localVarPath = strings.Replace(localVarPath, "{"+"collectionId"+"}", url.PathEscape(parameterToString(r.collectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"collectionItemId"+"}", url.PathEscape(parameterToString(r.collectionItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.address != nil {
		localVarQueryParams.Add("address", parameterToString(*r.address, ""))
	}
	if r.walletId != nil {
		localVarQueryParams.Add("walletId", parameterToString(*r.walletId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCollectionItemTimelockRequest struct {
	ctx context.Context
	ApiService *ItemsApiService
	collectionId string
	collectionItemId float32
}

func (r ApiGetCollectionItemTimelockRequest) Execute() (int32, *http.Response, error) {
	return r.ApiService.GetCollectionItemTimelockExecute(r)
}

/*
GetCollectionItemTimelock Get collection item timelock

Returns a timestamp (in seconds) for when the provided collectionItemId's transfer timelock expires. A value of 0 means the provided collectionItemId does not have a timelock set. Timelocks prevent items of a specific collectionItemId from being transferred until the set timelock timestamp has been surpassed.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param collectionId Any collection id within the MetaFab ecosystem.
 @param collectionItemId Any item id for the collection. Zero, or a positive integer.
 @return ApiGetCollectionItemTimelockRequest
*/
func (a *ItemsApiService) GetCollectionItemTimelock(ctx context.Context, collectionId string, collectionItemId float32) ApiGetCollectionItemTimelockRequest {
	return ApiGetCollectionItemTimelockRequest{
		ApiService: a,
		ctx: ctx,
		collectionId: collectionId,
		collectionItemId: collectionItemId,
	}
}

// Execute executes the request
//  @return int32
func (a *ItemsApiService) GetCollectionItemTimelockExecute(r ApiGetCollectionItemTimelockRequest) (int32, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemsApiService.GetCollectionItemTimelock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/collections/{collectionId}/items/{collectionItemId}/timelocks"
	localVarPath = strings.Replace(localVarPath, "{"+"collectionId"+"}", url.PathEscape(parameterToString(r.collectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"collectionItemId"+"}", url.PathEscape(parameterToString(r.collectionItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCollectionItemsRequest struct {
	ctx context.Context
	ApiService *ItemsApiService
	collectionId string
}

func (r ApiGetCollectionItemsRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetCollectionItemsExecute(r)
}

/*
GetCollectionItems Get collection items

Returns all collection items as an array of metadata objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param collectionId Any collection id within the MetaFab ecosystem.
 @return ApiGetCollectionItemsRequest
*/
func (a *ItemsApiService) GetCollectionItems(ctx context.Context, collectionId string) ApiGetCollectionItemsRequest {
	return ApiGetCollectionItemsRequest{
		ApiService: a,
		ctx: ctx,
		collectionId: collectionId,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *ItemsApiService) GetCollectionItemsExecute(r ApiGetCollectionItemsRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemsApiService.GetCollectionItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/collections/{collectionId}/items"
	localVarPath = strings.Replace(localVarPath, "{"+"collectionId"+"}", url.PathEscape(parameterToString(r.collectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCollectionRoleRequest struct {
	ctx context.Context
	ApiService *ItemsApiService
	collectionId string
	role *string
	address *string
	walletId *string
}

// A valid MetaFab role or bytes string representing a role, such as &#x60;0xc9eb32e43bf5ecbceacf00b32281dfc5d6d700a0db676ea26ccf938a385ac3b7&#x60;
func (r ApiGetCollectionRoleRequest) Role(role string) ApiGetCollectionRoleRequest {
	r.role = &role
	return r
}

// A valid EVM based address. For example, &#x60;0x39cb70F972E0EE920088AeF97Dbe5c6251a9c25D&#x60;.
func (r ApiGetCollectionRoleRequest) Address(address string) ApiGetCollectionRoleRequest {
	r.address = &address
	return r
}

// Any wallet id within the MetaFab ecosystem.
func (r ApiGetCollectionRoleRequest) WalletId(walletId string) ApiGetCollectionRoleRequest {
	r.walletId = &walletId
	return r
}

func (r ApiGetCollectionRoleRequest) Execute() (bool, *http.Response, error) {
	return r.ApiService.GetCollectionRoleExecute(r)
}

/*
GetCollectionRole Get collection role

Returns a boolean (true/false) representing if the provided role for this collection has been granted to the provided address or address associated with the provided walletId.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param collectionId Any collection id within the MetaFab ecosystem.
 @return ApiGetCollectionRoleRequest
*/
func (a *ItemsApiService) GetCollectionRole(ctx context.Context, collectionId string) ApiGetCollectionRoleRequest {
	return ApiGetCollectionRoleRequest{
		ApiService: a,
		ctx: ctx,
		collectionId: collectionId,
	}
}

// Execute executes the request
//  @return bool
func (a *ItemsApiService) GetCollectionRoleExecute(r ApiGetCollectionRoleRequest) (bool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemsApiService.GetCollectionRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/collections/{collectionId}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"collectionId"+"}", url.PathEscape(parameterToString(r.collectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.role == nil {
		return localVarReturnValue, nil, reportError("role is required and must be specified")
	}

	localVarQueryParams.Add("role", parameterToString(*r.role, ""))
	if r.address != nil {
		localVarQueryParams.Add("address", parameterToString(*r.address, ""))
	}
	if r.walletId != nil {
		localVarQueryParams.Add("walletId", parameterToString(*r.walletId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCollectionsRequest struct {
	ctx context.Context
	ApiService *ItemsApiService
	xGameKey *string
}

// The &#x60;publishedKey&#x60; of a specific game. This can be shared or included in game clients, websites, etc.
func (r ApiGetCollectionsRequest) XGameKey(xGameKey string) ApiGetCollectionsRequest {
	r.xGameKey = &xGameKey
	return r
}

func (r ApiGetCollectionsRequest) Execute() ([]GetCollections200ResponseInner, *http.Response, error) {
	return r.ApiService.GetCollectionsExecute(r)
}

/*
GetCollections Get collections

Returns an array of active item collections for the game associated with the provided `X-Game-Key`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCollectionsRequest
*/
func (a *ItemsApiService) GetCollections(ctx context.Context) ApiGetCollectionsRequest {
	return ApiGetCollectionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetCollections200ResponseInner
func (a *ItemsApiService) GetCollectionsExecute(r ApiGetCollectionsRequest) ([]GetCollections200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetCollections200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemsApiService.GetCollections")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/collections"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xGameKey == nil {
		return localVarReturnValue, nil, reportError("xGameKey is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-Game-Key"] = parameterToString(*r.xGameKey, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGrantCollectionRoleRequest struct {
	ctx context.Context
	ApiService *ItemsApiService
	collectionId string
	xAuthorization *string
	xPassword *string
	grantCollectionRoleRequest *GrantCollectionRoleRequest
}

// The &#x60;secretKey&#x60; of a specific game or the &#x60;accessToken&#x60; of a specific player.
func (r ApiGrantCollectionRoleRequest) XAuthorization(xAuthorization string) ApiGrantCollectionRoleRequest {
	r.xAuthorization = &xAuthorization
	return r
}

// The password of the authenticating game or player. Required to decrypt and perform blockchain transactions with the game or player primary wallet.
func (r ApiGrantCollectionRoleRequest) XPassword(xPassword string) ApiGrantCollectionRoleRequest {
	r.xPassword = &xPassword
	return r
}

func (r ApiGrantCollectionRoleRequest) GrantCollectionRoleRequest(grantCollectionRoleRequest GrantCollectionRoleRequest) ApiGrantCollectionRoleRequest {
	r.grantCollectionRoleRequest = &grantCollectionRoleRequest
	return r
}

func (r ApiGrantCollectionRoleRequest) Execute() (*TransactionModel, *http.Response, error) {
	return r.ApiService.GrantCollectionRoleExecute(r)
}

/*
GrantCollectionRole Grant collection role

Grants the provided role for the collection to the provided address or address associated with the provided walletId. Granted roles give different types of authority on behalf of the collection for specific players, addresses, or contracts to perform different types of permissioned collection operations.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param collectionId Any collection id within the MetaFab ecosystem.
 @return ApiGrantCollectionRoleRequest
*/
func (a *ItemsApiService) GrantCollectionRole(ctx context.Context, collectionId string) ApiGrantCollectionRoleRequest {
	return ApiGrantCollectionRoleRequest{
		ApiService: a,
		ctx: ctx,
		collectionId: collectionId,
	}
}

// Execute executes the request
//  @return TransactionModel
func (a *ItemsApiService) GrantCollectionRoleExecute(r ApiGrantCollectionRoleRequest) (*TransactionModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemsApiService.GrantCollectionRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/collections/{collectionId}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"collectionId"+"}", url.PathEscape(parameterToString(r.collectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthorization == nil {
		return localVarReturnValue, nil, reportError("xAuthorization is required and must be specified")
	}
	if r.xPassword == nil {
		return localVarReturnValue, nil, reportError("xPassword is required and must be specified")
	}
	if r.grantCollectionRoleRequest == nil {
		return localVarReturnValue, nil, reportError("grantCollectionRoleRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-Authorization"] = parameterToString(*r.xAuthorization, "")
	localVarHeaderParams["X-Password"] = parameterToString(*r.xPassword, "")
	// body params
	localVarPostBody = r.grantCollectionRoleRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMintCollectionItemRequest struct {
	ctx context.Context
	ApiService *ItemsApiService
	collectionId string
	collectionItemId float32
	xAuthorization *string
	xPassword *string
	mintCollectionItemRequest *MintCollectionItemRequest
}

// The &#x60;secretKey&#x60; of the authenticating game.
func (r ApiMintCollectionItemRequest) XAuthorization(xAuthorization string) ApiMintCollectionItemRequest {
	r.xAuthorization = &xAuthorization
	return r
}

// The password of the authenticating game. Required to decrypt and perform blockchain transactions with the game primary wallet.
func (r ApiMintCollectionItemRequest) XPassword(xPassword string) ApiMintCollectionItemRequest {
	r.xPassword = &xPassword
	return r
}

func (r ApiMintCollectionItemRequest) MintCollectionItemRequest(mintCollectionItemRequest MintCollectionItemRequest) ApiMintCollectionItemRequest {
	r.mintCollectionItemRequest = &mintCollectionItemRequest
	return r
}

func (r ApiMintCollectionItemRequest) Execute() (*TransactionModel, *http.Response, error) {
	return r.ApiService.MintCollectionItemExecute(r)
}

/*
MintCollectionItem Mint collection item

Creates (mints) the specified quantity of the provided collectionItemId to the provided wallet address or wallet address associated with the provided walletId.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param collectionId Any collection id within the MetaFab ecosystem.
 @param collectionItemId Any item id for the collection. Zero, or a positive integer.
 @return ApiMintCollectionItemRequest
*/
func (a *ItemsApiService) MintCollectionItem(ctx context.Context, collectionId string, collectionItemId float32) ApiMintCollectionItemRequest {
	return ApiMintCollectionItemRequest{
		ApiService: a,
		ctx: ctx,
		collectionId: collectionId,
		collectionItemId: collectionItemId,
	}
}

// Execute executes the request
//  @return TransactionModel
func (a *ItemsApiService) MintCollectionItemExecute(r ApiMintCollectionItemRequest) (*TransactionModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemsApiService.MintCollectionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/collections/{collectionId}/items/{collectionItemId}/mints"
	localVarPath = strings.Replace(localVarPath, "{"+"collectionId"+"}", url.PathEscape(parameterToString(r.collectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"collectionItemId"+"}", url.PathEscape(parameterToString(r.collectionItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthorization == nil {
		return localVarReturnValue, nil, reportError("xAuthorization is required and must be specified")
	}
	if r.xPassword == nil {
		return localVarReturnValue, nil, reportError("xPassword is required and must be specified")
	}
	if r.mintCollectionItemRequest == nil {
		return localVarReturnValue, nil, reportError("mintCollectionItemRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-Authorization"] = parameterToString(*r.xAuthorization, "")
	localVarHeaderParams["X-Password"] = parameterToString(*r.xPassword, "")
	// body params
	localVarPostBody = r.mintCollectionItemRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRevokeCollectionRoleRequest struct {
	ctx context.Context
	ApiService *ItemsApiService
	collectionId string
	xAuthorization *string
	xPassword *string
	revokeCollectionRoleRequest *RevokeCollectionRoleRequest
}

// The &#x60;secretKey&#x60; of a specific game or the &#x60;accessToken&#x60; of a specific player.
func (r ApiRevokeCollectionRoleRequest) XAuthorization(xAuthorization string) ApiRevokeCollectionRoleRequest {
	r.xAuthorization = &xAuthorization
	return r
}

// The password of the authenticating game or player. Required to decrypt and perform blockchain transactions with the game or player primary wallet.
func (r ApiRevokeCollectionRoleRequest) XPassword(xPassword string) ApiRevokeCollectionRoleRequest {
	r.xPassword = &xPassword
	return r
}

func (r ApiRevokeCollectionRoleRequest) RevokeCollectionRoleRequest(revokeCollectionRoleRequest RevokeCollectionRoleRequest) ApiRevokeCollectionRoleRequest {
	r.revokeCollectionRoleRequest = &revokeCollectionRoleRequest
	return r
}

func (r ApiRevokeCollectionRoleRequest) Execute() (*TransactionModel, *http.Response, error) {
	return r.ApiService.RevokeCollectionRoleExecute(r)
}

/*
RevokeCollectionRole Revoke collection role

Revokes the provided role for the collection to the provided address or address associated with the provided walletId.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param collectionId Any collection id within the MetaFab ecosystem.
 @return ApiRevokeCollectionRoleRequest
*/
func (a *ItemsApiService) RevokeCollectionRole(ctx context.Context, collectionId string) ApiRevokeCollectionRoleRequest {
	return ApiRevokeCollectionRoleRequest{
		ApiService: a,
		ctx: ctx,
		collectionId: collectionId,
	}
}

// Execute executes the request
//  @return TransactionModel
func (a *ItemsApiService) RevokeCollectionRoleExecute(r ApiRevokeCollectionRoleRequest) (*TransactionModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemsApiService.RevokeCollectionRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/collections/{collectionId}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"collectionId"+"}", url.PathEscape(parameterToString(r.collectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthorization == nil {
		return localVarReturnValue, nil, reportError("xAuthorization is required and must be specified")
	}
	if r.xPassword == nil {
		return localVarReturnValue, nil, reportError("xPassword is required and must be specified")
	}
	if r.revokeCollectionRoleRequest == nil {
		return localVarReturnValue, nil, reportError("revokeCollectionRoleRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-Authorization"] = parameterToString(*r.xAuthorization, "")
	localVarHeaderParams["X-Password"] = parameterToString(*r.xPassword, "")
	// body params
	localVarPostBody = r.revokeCollectionRoleRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetCollectionApprovalRequest struct {
	ctx context.Context
	ApiService *ItemsApiService
	collectionId string
	xAuthorization *string
	xPassword *string
	setCollectionApprovalRequest *SetCollectionApprovalRequest
}

// The &#x60;secretKey&#x60; of a specific game or the &#x60;accessToken&#x60; of a specific player.
func (r ApiSetCollectionApprovalRequest) XAuthorization(xAuthorization string) ApiSetCollectionApprovalRequest {
	r.xAuthorization = &xAuthorization
	return r
}

// The password of the authenticating game or player. Required to decrypt and perform blockchain transactions with the game or player primary wallet.
func (r ApiSetCollectionApprovalRequest) XPassword(xPassword string) ApiSetCollectionApprovalRequest {
	r.xPassword = &xPassword
	return r
}

func (r ApiSetCollectionApprovalRequest) SetCollectionApprovalRequest(setCollectionApprovalRequest SetCollectionApprovalRequest) ApiSetCollectionApprovalRequest {
	r.setCollectionApprovalRequest = &setCollectionApprovalRequest
	return r
}

func (r ApiSetCollectionApprovalRequest) Execute() (*TransactionModel, *http.Response, error) {
	return r.ApiService.SetCollectionApprovalExecute(r)
}

/*
SetCollectionApproval Set collection approval

Sets approval for the provided address or wallet address associated with the provided walletId to operate on behalf of the authenticating game or player's owned items for this collection. Setting an approved value of `true` allows the provided address or address associated with the provided walletId to transfer and burn items from this collection on behalf of the authenticated game or player's wallet address.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param collectionId Any collection id within the MetaFab ecosystem.
 @return ApiSetCollectionApprovalRequest
*/
func (a *ItemsApiService) SetCollectionApproval(ctx context.Context, collectionId string) ApiSetCollectionApprovalRequest {
	return ApiSetCollectionApprovalRequest{
		ApiService: a,
		ctx: ctx,
		collectionId: collectionId,
	}
}

// Execute executes the request
//  @return TransactionModel
func (a *ItemsApiService) SetCollectionApprovalExecute(r ApiSetCollectionApprovalRequest) (*TransactionModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemsApiService.SetCollectionApproval")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/collections/{collectionId}/approvals"
	localVarPath = strings.Replace(localVarPath, "{"+"collectionId"+"}", url.PathEscape(parameterToString(r.collectionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthorization == nil {
		return localVarReturnValue, nil, reportError("xAuthorization is required and must be specified")
	}
	if r.xPassword == nil {
		return localVarReturnValue, nil, reportError("xPassword is required and must be specified")
	}
	if r.setCollectionApprovalRequest == nil {
		return localVarReturnValue, nil, reportError("setCollectionApprovalRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-Authorization"] = parameterToString(*r.xAuthorization, "")
	localVarHeaderParams["X-Password"] = parameterToString(*r.xPassword, "")
	// body params
	localVarPostBody = r.setCollectionApprovalRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetCollectionItemTimelockRequest struct {
	ctx context.Context
	ApiService *ItemsApiService
	collectionId string
	collectionItemId float32
	xAuthorization *string
	xPassword *string
	setCollectionItemTimelockRequest *SetCollectionItemTimelockRequest
}

// The &#x60;secretKey&#x60; of the authenticating game.
func (r ApiSetCollectionItemTimelockRequest) XAuthorization(xAuthorization string) ApiSetCollectionItemTimelockRequest {
	r.xAuthorization = &xAuthorization
	return r
}

// The password of the authenticating game. Required to decrypt and perform blockchain transactions with the game primary wallet.
func (r ApiSetCollectionItemTimelockRequest) XPassword(xPassword string) ApiSetCollectionItemTimelockRequest {
	r.xPassword = &xPassword
	return r
}

func (r ApiSetCollectionItemTimelockRequest) SetCollectionItemTimelockRequest(setCollectionItemTimelockRequest SetCollectionItemTimelockRequest) ApiSetCollectionItemTimelockRequest {
	r.setCollectionItemTimelockRequest = &setCollectionItemTimelockRequest
	return r
}

func (r ApiSetCollectionItemTimelockRequest) Execute() (*TransactionModel, *http.Response, error) {
	return r.ApiService.SetCollectionItemTimelockExecute(r)
}

/*
SetCollectionItemTimelock Set collection item timelock

Sets the item timelock for the provided collection itemId. The timelock is a unix timestamp (in seconds) that defines a period in time of when an item may be transferred by players. Until the timelock timestamp has passed, the itemId for the given timelock may not be transferred, sold, traded, etc. A timelock of 0 (default) means that there is no timelock set on the itemId and it can be freely transferred, traded, etc.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param collectionId Any collection id within the MetaFab ecosystem.
 @param collectionItemId Any item id for the collection. Zero, or a positive integer.
 @return ApiSetCollectionItemTimelockRequest
*/
func (a *ItemsApiService) SetCollectionItemTimelock(ctx context.Context, collectionId string, collectionItemId float32) ApiSetCollectionItemTimelockRequest {
	return ApiSetCollectionItemTimelockRequest{
		ApiService: a,
		ctx: ctx,
		collectionId: collectionId,
		collectionItemId: collectionItemId,
	}
}

// Execute executes the request
//  @return TransactionModel
func (a *ItemsApiService) SetCollectionItemTimelockExecute(r ApiSetCollectionItemTimelockRequest) (*TransactionModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemsApiService.SetCollectionItemTimelock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/collections/{collectionId}/items/{collectionItemId}/timelocks"
	localVarPath = strings.Replace(localVarPath, "{"+"collectionId"+"}", url.PathEscape(parameterToString(r.collectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"collectionItemId"+"}", url.PathEscape(parameterToString(r.collectionItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthorization == nil {
		return localVarReturnValue, nil, reportError("xAuthorization is required and must be specified")
	}
	if r.xPassword == nil {
		return localVarReturnValue, nil, reportError("xPassword is required and must be specified")
	}
	if r.setCollectionItemTimelockRequest == nil {
		return localVarReturnValue, nil, reportError("setCollectionItemTimelockRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-Authorization"] = parameterToString(*r.xAuthorization, "")
	localVarHeaderParams["X-Password"] = parameterToString(*r.xPassword, "")
	// body params
	localVarPostBody = r.setCollectionItemTimelockRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTransferCollectionItemRequest struct {
	ctx context.Context
	ApiService *ItemsApiService
	collectionId string
	collectionItemId float32
	xAuthorization *string
	xPassword *string
	transferCollectionItemRequest *TransferCollectionItemRequest
}

// The &#x60;secretKey&#x60; of a specific game or the &#x60;accessToken&#x60; of a specific player.
func (r ApiTransferCollectionItemRequest) XAuthorization(xAuthorization string) ApiTransferCollectionItemRequest {
	r.xAuthorization = &xAuthorization
	return r
}

// The password of the authenticating game or player. Required to decrypt and perform blockchain transactions with the game or player primary wallet.
func (r ApiTransferCollectionItemRequest) XPassword(xPassword string) ApiTransferCollectionItemRequest {
	r.xPassword = &xPassword
	return r
}

func (r ApiTransferCollectionItemRequest) TransferCollectionItemRequest(transferCollectionItemRequest TransferCollectionItemRequest) ApiTransferCollectionItemRequest {
	r.transferCollectionItemRequest = &transferCollectionItemRequest
	return r
}

func (r ApiTransferCollectionItemRequest) Execute() (*TransactionModel, *http.Response, error) {
	return r.ApiService.TransferCollectionItemExecute(r)
}

/*
TransferCollectionItem Transfer collection item

Transfers specified quantity of itemId to the provided wallet address or wallet address associated with the provided walletId.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param collectionId Any collection id within the MetaFab ecosystem.
 @param collectionItemId Any item id for the collection. Zero, or a positive integer.
 @return ApiTransferCollectionItemRequest
*/
func (a *ItemsApiService) TransferCollectionItem(ctx context.Context, collectionId string, collectionItemId float32) ApiTransferCollectionItemRequest {
	return ApiTransferCollectionItemRequest{
		ApiService: a,
		ctx: ctx,
		collectionId: collectionId,
		collectionItemId: collectionItemId,
	}
}

// Execute executes the request
//  @return TransactionModel
func (a *ItemsApiService) TransferCollectionItemExecute(r ApiTransferCollectionItemRequest) (*TransactionModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemsApiService.TransferCollectionItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/collections/{collectionId}/items/{collectionItemId}/transfers"
	localVarPath = strings.Replace(localVarPath, "{"+"collectionId"+"}", url.PathEscape(parameterToString(r.collectionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"collectionItemId"+"}", url.PathEscape(parameterToString(r.collectionItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthorization == nil {
		return localVarReturnValue, nil, reportError("xAuthorization is required and must be specified")
	}
	if r.xPassword == nil {
		return localVarReturnValue, nil, reportError("xPassword is required and must be specified")
	}
	if r.transferCollectionItemRequest == nil {
		return localVarReturnValue, nil, reportError("transferCollectionItemRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-Authorization"] = parameterToString(*r.xAuthorization, "")
	localVarHeaderParams["X-Password"] = parameterToString(*r.xPassword, "")
	// body params
	localVarPostBody = r.transferCollectionItemRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
