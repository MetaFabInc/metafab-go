/*
MetaFab API

 Complete MetaFab API references and guides can be found at: https://trymetafab.com

API version: 1.2.1
Contact: metafabproject@gmail.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package metafab

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// ExchangesApiService ExchangesApi service
type ExchangesApiService service

type ApiCreateExchangeRequest struct {
	ctx context.Context
	ApiService *ExchangesApiService
	xAuthorization *string
	xPassword *string
	createExchangeRequest *CreateExchangeRequest
}

// The &#x60;secretKey&#x60; of the authenticating game.
func (r ApiCreateExchangeRequest) XAuthorization(xAuthorization string) ApiCreateExchangeRequest {
	r.xAuthorization = &xAuthorization
	return r
}

// The password of the authenticating game. Required to decrypt and perform blockchain transactions with the game primary wallet.
func (r ApiCreateExchangeRequest) XPassword(xPassword string) ApiCreateExchangeRequest {
	r.xPassword = &xPassword
	return r
}

func (r ApiCreateExchangeRequest) CreateExchangeRequest(createExchangeRequest CreateExchangeRequest) ApiCreateExchangeRequest {
	r.createExchangeRequest = &createExchangeRequest
	return r
}

func (r ApiCreateExchangeRequest) Execute() (*CreateExchange200Response, *http.Response, error) {
	return r.ApiService.CreateExchangeExecute(r)
}

/*
CreateExchange Create exchange

Creates a new game exchange and deploys a exchange contract on behalf of the authenticating game's primary wallet. The deployed exchange contract allows you to create fixed price rates for players to buy specific items from any item collection or ERC1155 contract. Additionally, an exchange allows you to create exchange offers for some set of item(s) to another set of item(s) or any mix of currency. Exchanges completely supports gasless player transactions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateExchangeRequest
*/
func (a *ExchangesApiService) CreateExchange(ctx context.Context) ApiCreateExchangeRequest {
	return ApiCreateExchangeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateExchange200Response
func (a *ExchangesApiService) CreateExchangeExecute(r ApiCreateExchangeRequest) (*CreateExchange200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateExchange200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExchangesApiService.CreateExchange")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/exchanges"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthorization == nil {
		return localVarReturnValue, nil, reportError("xAuthorization is required and must be specified")
	}
	if r.xPassword == nil {
		return localVarReturnValue, nil, reportError("xPassword is required and must be specified")
	}
	if r.createExchangeRequest == nil {
		return localVarReturnValue, nil, reportError("createExchangeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-Authorization"] = parameterToString(*r.xAuthorization, "")
	localVarHeaderParams["X-Password"] = parameterToString(*r.xPassword, "")
	// body params
	localVarPostBody = r.createExchangeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExchangeOfferRequest struct {
	ctx context.Context
	ApiService *ExchangesApiService
	exchangeId string
	exchangeOfferId string
}

func (r ApiGetExchangeOfferRequest) Execute() (*ExchangeOffer, *http.Response, error) {
	return r.ApiService.GetExchangeOfferExecute(r)
}

/*
GetExchangeOffer Get exchange offer

Returns a exchange offer object for the provided exchangeOfferId.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param exchangeId Any exchange id within the MetaFab ecosystem.
 @param exchangeOfferId Any offer id for the exchange. Zero, or a positive integer.
 @return ApiGetExchangeOfferRequest
*/
func (a *ExchangesApiService) GetExchangeOffer(ctx context.Context, exchangeId string, exchangeOfferId string) ApiGetExchangeOfferRequest {
	return ApiGetExchangeOfferRequest{
		ApiService: a,
		ctx: ctx,
		exchangeId: exchangeId,
		exchangeOfferId: exchangeOfferId,
	}
}

// Execute executes the request
//  @return ExchangeOffer
func (a *ExchangesApiService) GetExchangeOfferExecute(r ApiGetExchangeOfferRequest) (*ExchangeOffer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExchangeOffer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExchangesApiService.GetExchangeOffer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/exchanges/{exchangeId}/items/{exchangeOfferId}"
	localVarPath = strings.Replace(localVarPath, "{"+"exchangeId"+"}", url.PathEscape(parameterToString(r.exchangeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"exchangeOfferId"+"}", url.PathEscape(parameterToString(r.exchangeOfferId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExchangeOffersRequest struct {
	ctx context.Context
	ApiService *ExchangesApiService
	exchangeId string
}

func (r ApiGetExchangeOffersRequest) Execute() ([]ExchangeOffer, *http.Response, error) {
	return r.ApiService.GetExchangeOffersExecute(r)
}

/*
GetExchangeOffers Get exchange offers

Returns all exchange offers as an array of exchange offer objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param exchangeId Any exchange id within the MetaFab ecosystem.
 @return ApiGetExchangeOffersRequest
*/
func (a *ExchangesApiService) GetExchangeOffers(ctx context.Context, exchangeId string) ApiGetExchangeOffersRequest {
	return ApiGetExchangeOffersRequest{
		ApiService: a,
		ctx: ctx,
		exchangeId: exchangeId,
	}
}

// Execute executes the request
//  @return []ExchangeOffer
func (a *ExchangesApiService) GetExchangeOffersExecute(r ApiGetExchangeOffersRequest) ([]ExchangeOffer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ExchangeOffer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExchangesApiService.GetExchangeOffers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/exchanges/{exchangeId}/offers"
	localVarPath = strings.Replace(localVarPath, "{"+"exchangeId"+"}", url.PathEscape(parameterToString(r.exchangeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExchangesRequest struct {
	ctx context.Context
	ApiService *ExchangesApiService
	xGameKey *string
}

// The &#x60;publishedKey&#x60; of a specific game. This can be shared or included in game clients, websites, etc.
func (r ApiGetExchangesRequest) XGameKey(xGameKey string) ApiGetExchangesRequest {
	r.xGameKey = &xGameKey
	return r
}

func (r ApiGetExchangesRequest) Execute() ([]GetExchanges200ResponseInner, *http.Response, error) {
	return r.ApiService.GetExchangesExecute(r)
}

/*
GetExchanges Get exchanges

Returns an array of active exchanges for the game associated with the provided `X-Game-Key`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetExchangesRequest
*/
func (a *ExchangesApiService) GetExchanges(ctx context.Context) ApiGetExchangesRequest {
	return ApiGetExchangesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetExchanges200ResponseInner
func (a *ExchangesApiService) GetExchangesExecute(r ApiGetExchangesRequest) ([]GetExchanges200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetExchanges200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExchangesApiService.GetExchanges")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/exchanges"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xGameKey == nil {
		return localVarReturnValue, nil, reportError("xGameKey is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-Game-Key"] = parameterToString(*r.xGameKey, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveExchangeOfferRequest struct {
	ctx context.Context
	ApiService *ExchangesApiService
	exchangeId string
	exchangeOfferId string
	xAuthorization *string
	xPassword *string
}

// The &#x60;secretKey&#x60; of the authenticating game.
func (r ApiRemoveExchangeOfferRequest) XAuthorization(xAuthorization string) ApiRemoveExchangeOfferRequest {
	r.xAuthorization = &xAuthorization
	return r
}

// The password of the authenticating game. Required to decrypt and perform blockchain transactions with the game primary wallet.
func (r ApiRemoveExchangeOfferRequest) XPassword(xPassword string) ApiRemoveExchangeOfferRequest {
	r.xPassword = &xPassword
	return r
}

func (r ApiRemoveExchangeOfferRequest) Execute() (*TransactionModel, *http.Response, error) {
	return r.ApiService.RemoveExchangeOfferExecute(r)
}

/*
RemoveExchangeOffer Remove exchange offer

Removes the provided offerId from the provided exchange. Removed offers can no longer be used.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param exchangeId Any exchange id within the MetaFab ecosystem.
 @param exchangeOfferId Any offer id for the exchange. Zero, or a positive integer.
 @return ApiRemoveExchangeOfferRequest
*/
func (a *ExchangesApiService) RemoveExchangeOffer(ctx context.Context, exchangeId string, exchangeOfferId string) ApiRemoveExchangeOfferRequest {
	return ApiRemoveExchangeOfferRequest{
		ApiService: a,
		ctx: ctx,
		exchangeId: exchangeId,
		exchangeOfferId: exchangeOfferId,
	}
}

// Execute executes the request
//  @return TransactionModel
func (a *ExchangesApiService) RemoveExchangeOfferExecute(r ApiRemoveExchangeOfferRequest) (*TransactionModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExchangesApiService.RemoveExchangeOffer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/exchanges/{exchangeId}/offers/{exchangeOfferId}"
	localVarPath = strings.Replace(localVarPath, "{"+"exchangeId"+"}", url.PathEscape(parameterToString(r.exchangeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"exchangeOfferId"+"}", url.PathEscape(parameterToString(r.exchangeOfferId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthorization == nil {
		return localVarReturnValue, nil, reportError("xAuthorization is required and must be specified")
	}
	if r.xPassword == nil {
		return localVarReturnValue, nil, reportError("xPassword is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-Authorization"] = parameterToString(*r.xAuthorization, "")
	localVarHeaderParams["X-Password"] = parameterToString(*r.xPassword, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetExchangeOfferRequest struct {
	ctx context.Context
	ApiService *ExchangesApiService
	exchangeId string
	xAuthorization *string
	xPassword *string
	setExchangeOfferRequest *SetExchangeOfferRequest
}

// The &#x60;secretKey&#x60; of the authenticating game.
func (r ApiSetExchangeOfferRequest) XAuthorization(xAuthorization string) ApiSetExchangeOfferRequest {
	r.xAuthorization = &xAuthorization
	return r
}

// The password of the authenticating game. Required to decrypt and perform blockchain transactions with the game primary wallet.
func (r ApiSetExchangeOfferRequest) XPassword(xPassword string) ApiSetExchangeOfferRequest {
	r.xPassword = &xPassword
	return r
}

func (r ApiSetExchangeOfferRequest) SetExchangeOfferRequest(setExchangeOfferRequest SetExchangeOfferRequest) ApiSetExchangeOfferRequest {
	r.setExchangeOfferRequest = &setExchangeOfferRequest
	return r
}

func (r ApiSetExchangeOfferRequest) Execute() (*TransactionModel, *http.Response, error) {
	return r.ApiService.SetExchangeOfferExecute(r)
}

/*
SetExchangeOffer Set exchange offer

Sets a new exchange offer or updates an existing one for the provided id. Exchange offers allow currency to item, item to currency or item to item exchanges.

All request fields besides `id` are optional. Any optional fields omitted will not be used for the offer. This allows you to create many different combinations of offers. For example, you can create an offer that may require 3 unique item ids of specified quantities from a given item collection and gives the user 1 new unique item id in exchange.

Another example, you may want to make an exchange offer from one ERC20 token to another. This is also possible - simple set the input and output currency fields and leave the others blank.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param exchangeId Any exchange id within the MetaFab ecosystem.
 @return ApiSetExchangeOfferRequest
*/
func (a *ExchangesApiService) SetExchangeOffer(ctx context.Context, exchangeId string) ApiSetExchangeOfferRequest {
	return ApiSetExchangeOfferRequest{
		ApiService: a,
		ctx: ctx,
		exchangeId: exchangeId,
	}
}

// Execute executes the request
//  @return TransactionModel
func (a *ExchangesApiService) SetExchangeOfferExecute(r ApiSetExchangeOfferRequest) (*TransactionModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExchangesApiService.SetExchangeOffer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/exchanges/{exchangeId}/offers"
	localVarPath = strings.Replace(localVarPath, "{"+"exchangeId"+"}", url.PathEscape(parameterToString(r.exchangeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthorization == nil {
		return localVarReturnValue, nil, reportError("xAuthorization is required and must be specified")
	}
	if r.xPassword == nil {
		return localVarReturnValue, nil, reportError("xPassword is required and must be specified")
	}
	if r.setExchangeOfferRequest == nil {
		return localVarReturnValue, nil, reportError("setExchangeOfferRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-Authorization"] = parameterToString(*r.xAuthorization, "")
	localVarHeaderParams["X-Password"] = parameterToString(*r.xPassword, "")
	// body params
	localVarPostBody = r.setExchangeOfferRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUseExchangeOfferRequest struct {
	ctx context.Context
	ApiService *ExchangesApiService
	exchangeId string
	exchangeOfferId string
	xAuthorization *string
	xPassword *string
}

// The &#x60;secretKey&#x60; of a specific game or the &#x60;accessToken&#x60; of a specific player.
func (r ApiUseExchangeOfferRequest) XAuthorization(xAuthorization string) ApiUseExchangeOfferRequest {
	r.xAuthorization = &xAuthorization
	return r
}

// The password of the authenticating game or player. Required to decrypt and perform blockchain transactions with the game or player primary wallet.
func (r ApiUseExchangeOfferRequest) XPassword(xPassword string) ApiUseExchangeOfferRequest {
	r.xPassword = &xPassword
	return r
}

func (r ApiUseExchangeOfferRequest) Execute() (*TransactionModel, *http.Response, error) {
	return r.ApiService.UseExchangeOfferExecute(r)
}

/*
UseExchangeOffer Use exchange offer

Uses an exchange offer. The required (input) item(s) and/or currency are removed from the wallet or player wallet using the offer. The given (output) item(s) and/or currency are given to the wallet or player wallet using the offer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param exchangeId Any exchange id within the MetaFab ecosystem.
 @param exchangeOfferId Any offer id for the exchange. Zero, or a positive integer.
 @return ApiUseExchangeOfferRequest
*/
func (a *ExchangesApiService) UseExchangeOffer(ctx context.Context, exchangeId string, exchangeOfferId string) ApiUseExchangeOfferRequest {
	return ApiUseExchangeOfferRequest{
		ApiService: a,
		ctx: ctx,
		exchangeId: exchangeId,
		exchangeOfferId: exchangeOfferId,
	}
}

// Execute executes the request
//  @return TransactionModel
func (a *ExchangesApiService) UseExchangeOfferExecute(r ApiUseExchangeOfferRequest) (*TransactionModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExchangesApiService.UseExchangeOffer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/exchanges/{exchangeId}/offers/{exchangeOfferId}/uses"
	localVarPath = strings.Replace(localVarPath, "{"+"exchangeId"+"}", url.PathEscape(parameterToString(r.exchangeId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"exchangeOfferId"+"}", url.PathEscape(parameterToString(r.exchangeOfferId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthorization == nil {
		return localVarReturnValue, nil, reportError("xAuthorization is required and must be specified")
	}
	if r.xPassword == nil {
		return localVarReturnValue, nil, reportError("xPassword is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-Authorization"] = parameterToString(*r.xAuthorization, "")
	localVarHeaderParams["X-Password"] = parameterToString(*r.xPassword, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWithdrawFromExchangeRequest struct {
	ctx context.Context
	ApiService *ExchangesApiService
	exchangeId string
	xAuthorization *string
	xPassword *string
	withdrawFromExchangeRequest *WithdrawFromExchangeRequest
}

// The &#x60;secretKey&#x60; of the authenticating game.
func (r ApiWithdrawFromExchangeRequest) XAuthorization(xAuthorization string) ApiWithdrawFromExchangeRequest {
	r.xAuthorization = &xAuthorization
	return r
}

// The password of the authenticating game. Required to decrypt and perform blockchain transactions with the game primary wallet.
func (r ApiWithdrawFromExchangeRequest) XPassword(xPassword string) ApiWithdrawFromExchangeRequest {
	r.xPassword = &xPassword
	return r
}

func (r ApiWithdrawFromExchangeRequest) WithdrawFromExchangeRequest(withdrawFromExchangeRequest WithdrawFromExchangeRequest) ApiWithdrawFromExchangeRequest {
	r.withdrawFromExchangeRequest = &withdrawFromExchangeRequest
	return r
}

func (r ApiWithdrawFromExchangeRequest) Execute() (*TransactionModel, *http.Response, error) {
	return r.ApiService.WithdrawFromExchangeExecute(r)
}

/*
WithdrawFromExchange Withdraw from exchange

Withdraws native token, currency or items from a exchange. Whenever an exchange offer has input requirements, the native tokens, currencies or items for the requirements of that offer are deposited into the exchange contract when the offer is used. These can be withdrawn to any other address.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param exchangeId Any exchange id within the MetaFab ecosystem.
 @return ApiWithdrawFromExchangeRequest
*/
func (a *ExchangesApiService) WithdrawFromExchange(ctx context.Context, exchangeId string) ApiWithdrawFromExchangeRequest {
	return ApiWithdrawFromExchangeRequest{
		ApiService: a,
		ctx: ctx,
		exchangeId: exchangeId,
	}
}

// Execute executes the request
//  @return TransactionModel
func (a *ExchangesApiService) WithdrawFromExchangeExecute(r ApiWithdrawFromExchangeRequest) (*TransactionModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExchangesApiService.WithdrawFromExchange")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/exchanges/{exchangeId}/withdrawals"
	localVarPath = strings.Replace(localVarPath, "{"+"exchangeId"+"}", url.PathEscape(parameterToString(r.exchangeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthorization == nil {
		return localVarReturnValue, nil, reportError("xAuthorization is required and must be specified")
	}
	if r.xPassword == nil {
		return localVarReturnValue, nil, reportError("xPassword is required and must be specified")
	}
	if r.withdrawFromExchangeRequest == nil {
		return localVarReturnValue, nil, reportError("withdrawFromExchangeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-Authorization"] = parameterToString(*r.xAuthorization, "")
	localVarHeaderParams["X-Password"] = parameterToString(*r.xPassword, "")
	// body params
	localVarPostBody = r.withdrawFromExchangeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
