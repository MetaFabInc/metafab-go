/*
MetaFab API

Complete MetaFab API references and guides can be found at: https://trymetafab.com

API version: 1.5.1
Contact: metafabproject@gmail.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package metafab

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// EcosystemsApiService EcosystemsApi service
type EcosystemsApiService service

type ApiApproveEcosystemGameRequest struct {
	ctx context.Context
	ApiService *EcosystemsApiService
	ecosystemId string
	xAuthorization *string
	approveEcosystemGameRequest *ApproveEcosystemGameRequest
}

// The &#x60;secretKey&#x60; of the authenticating ecosystem.
func (r ApiApproveEcosystemGameRequest) XAuthorization(xAuthorization string) ApiApproveEcosystemGameRequest {
	r.xAuthorization = &xAuthorization
	return r
}

func (r ApiApproveEcosystemGameRequest) ApproveEcosystemGameRequest(approveEcosystemGameRequest ApproveEcosystemGameRequest) ApiApproveEcosystemGameRequest {
	r.approveEcosystemGameRequest = &approveEcosystemGameRequest
	return r
}

func (r ApiApproveEcosystemGameRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApproveEcosystemGameExecute(r)
}

/*
ApproveEcosystemGame Approve ecosystem game

Approves a game for an ecosystem. By approving a game, it allows that game to integrate the ability for profile accounts from an ecosystem to login directly to the approved game and play. This also allows games to request access to assets held at the profile level for the game to frictionlessly interact with on behalf of the profile.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ecosystemId The ecosystem id of the authenticating ecosystem.
 @return ApiApproveEcosystemGameRequest
*/
func (a *EcosystemsApiService) ApproveEcosystemGame(ctx context.Context, ecosystemId string) ApiApproveEcosystemGameRequest {
	return ApiApproveEcosystemGameRequest{
		ApiService: a,
		ctx: ctx,
		ecosystemId: ecosystemId,
	}
}

// Execute executes the request
func (a *EcosystemsApiService) ApproveEcosystemGameExecute(r ApiApproveEcosystemGameRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcosystemsApiService.ApproveEcosystemGame")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/ecosystems/{ecosystemId}/games"
	localVarPath = strings.Replace(localVarPath, "{"+"ecosystemId"+"}", url.PathEscape(parameterToString(r.ecosystemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthorization == nil {
		return nil, reportError("xAuthorization is required and must be specified")
	}
	if r.approveEcosystemGameRequest == nil {
		return nil, reportError("approveEcosystemGameRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-Authorization"] = parameterToString(*r.xAuthorization, "")
	// body params
	localVarPostBody = r.approveEcosystemGameRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAuthEcosystemRequest struct {
	ctx context.Context
	ApiService *EcosystemsApiService
}

func (r ApiAuthEcosystemRequest) Execute() (*EcosystemModel, *http.Response, error) {
	return r.ApiService.AuthEcosystemExecute(r)
}

/*
AuthEcosystem Authenticate ecosystem

Returns an existing ecosystem object containing authorization keys when provided a valid email (in place of username) and password login using Basic Auth.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthEcosystemRequest
*/
func (a *EcosystemsApiService) AuthEcosystem(ctx context.Context) ApiAuthEcosystemRequest {
	return ApiAuthEcosystemRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EcosystemModel
func (a *EcosystemsApiService) AuthEcosystemExecute(r ApiAuthEcosystemRequest) (*EcosystemModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EcosystemModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcosystemsApiService.AuthEcosystem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/ecosystems/auth"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthProfileRequest struct {
	ctx context.Context
	ApiService *EcosystemsApiService
	xEcosystemKey *string
}

// The &#x60;publishedKey&#x60; of a specific ecosystem. This can be shared or included in clients, websites, etc.
func (r ApiAuthProfileRequest) XEcosystemKey(xEcosystemKey string) ApiAuthProfileRequest {
	r.xEcosystemKey = &xEcosystemKey
	return r
}

func (r ApiAuthProfileRequest) Execute() (*AuthProfile200Response, *http.Response, error) {
	return r.ApiService.AuthProfileExecute(r)
}

/*
AuthProfile Authenticate profile

Returns an existing profile object containing access token, wallet, and other details when provided a valid profile username and password login using Basic Auth.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthProfileRequest
*/
func (a *EcosystemsApiService) AuthProfile(ctx context.Context) ApiAuthProfileRequest {
	return ApiAuthProfileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthProfile200Response
func (a *EcosystemsApiService) AuthProfileExecute(r ApiAuthProfileRequest) (*AuthProfile200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthProfile200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcosystemsApiService.AuthProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/profiles/auth"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xEcosystemKey == nil {
		return localVarReturnValue, nil, reportError("xEcosystemKey is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-Ecosystem-Key"] = parameterToString(*r.xEcosystemKey, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthProfilePlayerRequest struct {
	ctx context.Context
	ApiService *EcosystemsApiService
	profileId string
	gameId string
	xAuthorization *string
	xWalletDecryptKey *string
	xUsername *string
}

// The &#x60;accessToken&#x60; of the authenticating profile.
func (r ApiAuthProfilePlayerRequest) XAuthorization(xAuthorization string) ApiAuthProfilePlayerRequest {
	r.xAuthorization = &xAuthorization
	return r
}

// The &#x60;walletDecryptKey&#x60; of the authenticating profile. Required to decrypt and perform blockchain transactions with the profile wallet.
func (r ApiAuthProfilePlayerRequest) XWalletDecryptKey(xWalletDecryptKey string) ApiAuthProfilePlayerRequest {
	r.xWalletDecryptKey = &xWalletDecryptKey
	return r
}

// The username of a player.
func (r ApiAuthProfilePlayerRequest) XUsername(xUsername string) ApiAuthProfilePlayerRequest {
	r.xUsername = &xUsername
	return r
}

func (r ApiAuthProfilePlayerRequest) Execute() (*AuthPlayer200Response, *http.Response, error) {
	return r.ApiService.AuthProfilePlayerExecute(r)
}

/*
AuthProfilePlayer Authenticate profile player

Returns an existing player object containing access token, wallet, wallet decrypt key, profile authorization and other details for a game when provided profile authentication and the player's username.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId The profile id of the authenticating profile.
 @param gameId Any game id within the MetaFab platform.
 @return ApiAuthProfilePlayerRequest
*/
func (a *EcosystemsApiService) AuthProfilePlayer(ctx context.Context, profileId string, gameId string) ApiAuthProfilePlayerRequest {
	return ApiAuthProfilePlayerRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
		gameId: gameId,
	}
}

// Execute executes the request
//  @return AuthPlayer200Response
func (a *EcosystemsApiService) AuthProfilePlayerExecute(r ApiAuthProfilePlayerRequest) (*AuthPlayer200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthPlayer200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcosystemsApiService.AuthProfilePlayer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/profiles/{profileId}/games/{gameId}/players/auth"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterToString(r.profileId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"gameId"+"}", url.PathEscape(parameterToString(r.gameId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthorization == nil {
		return localVarReturnValue, nil, reportError("xAuthorization is required and must be specified")
	}
	if r.xWalletDecryptKey == nil {
		return localVarReturnValue, nil, reportError("xWalletDecryptKey is required and must be specified")
	}
	if r.xUsername == nil {
		return localVarReturnValue, nil, reportError("xUsername is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-Authorization"] = parameterToString(*r.xAuthorization, "")
	localVarHeaderParams["X-Wallet-Decrypt-Key"] = parameterToString(*r.xWalletDecryptKey, "")
	localVarHeaderParams["X-Username"] = parameterToString(*r.xUsername, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateEcosystemRequest struct {
	ctx context.Context
	ApiService *EcosystemsApiService
	createEcosystemRequest *CreateEcosystemRequest
}

func (r ApiCreateEcosystemRequest) CreateEcosystemRequest(createEcosystemRequest CreateEcosystemRequest) ApiCreateEcosystemRequest {
	r.createEcosystemRequest = &createEcosystemRequest
	return r
}

func (r ApiCreateEcosystemRequest) Execute() (*EcosystemModel, *http.Response, error) {
	return r.ApiService.CreateEcosystemExecute(r)
}

/*
CreateEcosystem Create ecosystem

Create a new ecosystem. An ecosystem is a parent entity that many profiles live under for a given ecosystem of games. Ecosystems allow your players to create one profile within your ecosystem that allows a single account and wallet to be used across all of the approved games in your ecosystem that they play.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateEcosystemRequest
*/
func (a *EcosystemsApiService) CreateEcosystem(ctx context.Context) ApiCreateEcosystemRequest {
	return ApiCreateEcosystemRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EcosystemModel
func (a *EcosystemsApiService) CreateEcosystemExecute(r ApiCreateEcosystemRequest) (*EcosystemModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EcosystemModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcosystemsApiService.CreateEcosystem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/ecosystems"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createEcosystemRequest == nil {
		return localVarReturnValue, nil, reportError("createEcosystemRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createEcosystemRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateProfileRequest struct {
	ctx context.Context
	ApiService *EcosystemsApiService
	xEcosystemKey *string
	createProfileRequest *CreateProfileRequest
}

// The &#x60;publishedKey&#x60; of a specific ecosystem. This can be shared or included in clients, websites, etc.
func (r ApiCreateProfileRequest) XEcosystemKey(xEcosystemKey string) ApiCreateProfileRequest {
	r.xEcosystemKey = &xEcosystemKey
	return r
}

func (r ApiCreateProfileRequest) CreateProfileRequest(createProfileRequest CreateProfileRequest) ApiCreateProfileRequest {
	r.createProfileRequest = &createProfileRequest
	return r
}

func (r ApiCreateProfileRequest) Execute() (*AuthProfile200Response, *http.Response, error) {
	return r.ApiService.CreateProfileExecute(r)
}

/*
CreateProfile Create profile

Create a new profile. Profiles are automatically associated with an internally managed wallet. Profiles can be thought of as a umbrella account that can be used to sign into and create player accounts across many games and have a singular asset store wallet at the profile level that can be used across all connected player accounts for games those player accounts are a part of.

Profiles are associated to a parent ecosystem of games. This allows an ecosystem to approve a permissioned set of games that can request authorized wallet permissions from profiles of players for their game.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateProfileRequest
*/
func (a *EcosystemsApiService) CreateProfile(ctx context.Context) ApiCreateProfileRequest {
	return ApiCreateProfileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthProfile200Response
func (a *EcosystemsApiService) CreateProfileExecute(r ApiCreateProfileRequest) (*AuthProfile200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthProfile200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcosystemsApiService.CreateProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/profiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xEcosystemKey == nil {
		return localVarReturnValue, nil, reportError("xEcosystemKey is required and must be specified")
	}
	if r.createProfileRequest == nil {
		return localVarReturnValue, nil, reportError("createProfileRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-Ecosystem-Key"] = parameterToString(*r.xEcosystemKey, "")
	// body params
	localVarPostBody = r.createProfileRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateProfilePlayerRequest struct {
	ctx context.Context
	ApiService *EcosystemsApiService
	profileId string
	gameId string
	xAuthorization *string
	xWalletDecryptKey *string
	createProfilePlayerRequest *CreateProfilePlayerRequest
}

// The &#x60;accessToken&#x60; of the authenticating profile.
func (r ApiCreateProfilePlayerRequest) XAuthorization(xAuthorization string) ApiCreateProfilePlayerRequest {
	r.xAuthorization = &xAuthorization
	return r
}

// The &#x60;walletDecryptKey&#x60; of the authenticating profile. Required to decrypt and perform blockchain transactions with the profile wallet.
func (r ApiCreateProfilePlayerRequest) XWalletDecryptKey(xWalletDecryptKey string) ApiCreateProfilePlayerRequest {
	r.xWalletDecryptKey = &xWalletDecryptKey
	return r
}

func (r ApiCreateProfilePlayerRequest) CreateProfilePlayerRequest(createProfilePlayerRequest CreateProfilePlayerRequest) ApiCreateProfilePlayerRequest {
	r.createProfilePlayerRequest = &createProfilePlayerRequest
	return r
}

func (r ApiCreateProfilePlayerRequest) Execute() (*AuthPlayer200Response, *http.Response, error) {
	return r.ApiService.CreateProfilePlayerExecute(r)
}

/*
CreateProfilePlayer Create profile player

Creates a new player account for the provided game id linked to the authenticating profile. The created player account will default to using the parent profile's wallet for any transactions, wallet content balance checks and verifications, and more.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId The profile id of the authenticating profile.
 @param gameId Any game id within the MetaFab platform.
 @return ApiCreateProfilePlayerRequest
*/
func (a *EcosystemsApiService) CreateProfilePlayer(ctx context.Context, profileId string, gameId string) ApiCreateProfilePlayerRequest {
	return ApiCreateProfilePlayerRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
		gameId: gameId,
	}
}

// Execute executes the request
//  @return AuthPlayer200Response
func (a *EcosystemsApiService) CreateProfilePlayerExecute(r ApiCreateProfilePlayerRequest) (*AuthPlayer200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthPlayer200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcosystemsApiService.CreateProfilePlayer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/profiles/{profileId}/games/{gameId}/players"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterToString(r.profileId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"gameId"+"}", url.PathEscape(parameterToString(r.gameId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthorization == nil {
		return localVarReturnValue, nil, reportError("xAuthorization is required and must be specified")
	}
	if r.xWalletDecryptKey == nil {
		return localVarReturnValue, nil, reportError("xWalletDecryptKey is required and must be specified")
	}
	if r.createProfilePlayerRequest == nil {
		return localVarReturnValue, nil, reportError("createProfilePlayerRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-Authorization"] = parameterToString(*r.xAuthorization, "")
	localVarHeaderParams["X-Wallet-Decrypt-Key"] = parameterToString(*r.xWalletDecryptKey, "")
	// body params
	localVarPostBody = r.createProfilePlayerRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEcosystemRequest struct {
	ctx context.Context
	ApiService *EcosystemsApiService
	ecosystemId string
}

func (r ApiGetEcosystemRequest) Execute() (*PublicEcosystem, *http.Response, error) {
	return r.ApiService.GetEcosystemExecute(r)
}

/*
GetEcosystem Get ecosystem

Returns a ecosystem object for the provided ecosystem id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ecosystemId Any ecosystem id within the MetaFab platform.
 @return ApiGetEcosystemRequest
*/
func (a *EcosystemsApiService) GetEcosystem(ctx context.Context, ecosystemId string) ApiGetEcosystemRequest {
	return ApiGetEcosystemRequest{
		ApiService: a,
		ctx: ctx,
		ecosystemId: ecosystemId,
	}
}

// Execute executes the request
//  @return PublicEcosystem
func (a *EcosystemsApiService) GetEcosystemExecute(r ApiGetEcosystemRequest) (*PublicEcosystem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PublicEcosystem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcosystemsApiService.GetEcosystem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/ecosystems/{ecosystemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"ecosystemId"+"}", url.PathEscape(parameterToString(r.ecosystemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEcosystemGameRequest struct {
	ctx context.Context
	ApiService *EcosystemsApiService
	ecosystemId string
	gameId string
}

func (r ApiGetEcosystemGameRequest) Execute() (*PublicGame, *http.Response, error) {
	return r.ApiService.GetEcosystemGameExecute(r)
}

/*
GetEcosystemGame Get ecosystem game

Returns a game object for the provided game id that the ecosystem has approved.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ecosystemId Any ecosystem id within the MetaFab platform.
 @param gameId Any game id within the MetaFab platform.
 @return ApiGetEcosystemGameRequest
*/
func (a *EcosystemsApiService) GetEcosystemGame(ctx context.Context, ecosystemId string, gameId string) ApiGetEcosystemGameRequest {
	return ApiGetEcosystemGameRequest{
		ApiService: a,
		ctx: ctx,
		ecosystemId: ecosystemId,
		gameId: gameId,
	}
}

// Execute executes the request
//  @return PublicGame
func (a *EcosystemsApiService) GetEcosystemGameExecute(r ApiGetEcosystemGameRequest) (*PublicGame, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PublicGame
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcosystemsApiService.GetEcosystemGame")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/ecosystems/{ecosystemId}/games/{gameId}"
	localVarPath = strings.Replace(localVarPath, "{"+"ecosystemId"+"}", url.PathEscape(parameterToString(r.ecosystemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"gameId"+"}", url.PathEscape(parameterToString(r.gameId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEcosystemGamesRequest struct {
	ctx context.Context
	ApiService *EcosystemsApiService
	ecosystemId string
}

func (r ApiGetEcosystemGamesRequest) Execute() ([]PublicGame, *http.Response, error) {
	return r.ApiService.GetEcosystemGamesExecute(r)
}

/*
GetEcosystemGames Get ecosystem games

Returns an array of games the ecosystem has approved.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ecosystemId Any ecosystem id within the MetaFab platform.
 @return ApiGetEcosystemGamesRequest
*/
func (a *EcosystemsApiService) GetEcosystemGames(ctx context.Context, ecosystemId string) ApiGetEcosystemGamesRequest {
	return ApiGetEcosystemGamesRequest{
		ApiService: a,
		ctx: ctx,
		ecosystemId: ecosystemId,
	}
}

// Execute executes the request
//  @return []PublicGame
func (a *EcosystemsApiService) GetEcosystemGamesExecute(r ApiGetEcosystemGamesRequest) ([]PublicGame, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PublicGame
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcosystemsApiService.GetEcosystemGames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/ecosystems/{ecosystemId}/games"
	localVarPath = strings.Replace(localVarPath, "{"+"ecosystemId"+"}", url.PathEscape(parameterToString(r.ecosystemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProfileGameRequest struct {
	ctx context.Context
	ApiService *EcosystemsApiService
	profileId string
	gameId string
	xAuthorization *string
}

// The &#x60;accessToken&#x60; of the authenticating profile.
func (r ApiGetProfileGameRequest) XAuthorization(xAuthorization string) ApiGetProfileGameRequest {
	r.xAuthorization = &xAuthorization
	return r
}

func (r ApiGetProfileGameRequest) Execute() (*GetProfileGames200ResponseInner, *http.Response, error) {
	return r.ApiService.GetProfileGameExecute(r)
}

/*
GetProfileGame Get profile game

Returns a game this profile has connected player accounts for.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId The profile id of the authenticating profile.
 @param gameId Any game id within the MetaFab platform.
 @return ApiGetProfileGameRequest
*/
func (a *EcosystemsApiService) GetProfileGame(ctx context.Context, profileId string, gameId string) ApiGetProfileGameRequest {
	return ApiGetProfileGameRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
		gameId: gameId,
	}
}

// Execute executes the request
//  @return GetProfileGames200ResponseInner
func (a *EcosystemsApiService) GetProfileGameExecute(r ApiGetProfileGameRequest) (*GetProfileGames200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetProfileGames200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcosystemsApiService.GetProfileGame")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/profiles/{profileId}/games/{gameId}"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterToString(r.profileId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"gameId"+"}", url.PathEscape(parameterToString(r.gameId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthorization == nil {
		return localVarReturnValue, nil, reportError("xAuthorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-Authorization"] = parameterToString(*r.xAuthorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProfileGamesRequest struct {
	ctx context.Context
	ApiService *EcosystemsApiService
	profileId string
	xAuthorization *string
}

// The &#x60;accessToken&#x60; of the authenticating profile.
func (r ApiGetProfileGamesRequest) XAuthorization(xAuthorization string) ApiGetProfileGamesRequest {
	r.xAuthorization = &xAuthorization
	return r
}

func (r ApiGetProfileGamesRequest) Execute() ([]GetProfileGames200ResponseInner, *http.Response, error) {
	return r.ApiService.GetProfileGamesExecute(r)
}

/*
GetProfileGames Get profile games

Returns an array of games the authorized profile has connected player accounts for.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId The profile id of the authenticating profile.
 @return ApiGetProfileGamesRequest
*/
func (a *EcosystemsApiService) GetProfileGames(ctx context.Context, profileId string) ApiGetProfileGamesRequest {
	return ApiGetProfileGamesRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return []GetProfileGames200ResponseInner
func (a *EcosystemsApiService) GetProfileGamesExecute(r ApiGetProfileGamesRequest) ([]GetProfileGames200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetProfileGames200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcosystemsApiService.GetProfileGames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/profiles/{profileId}/games"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterToString(r.profileId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthorization == nil {
		return localVarReturnValue, nil, reportError("xAuthorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-Authorization"] = parameterToString(*r.xAuthorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnapproveEcosystemGameRequest struct {
	ctx context.Context
	ApiService *EcosystemsApiService
	ecosystemId string
	gameId string
	xAuthorization *string
}

// The &#x60;secretKey&#x60; of the authenticating ecosystem.
func (r ApiUnapproveEcosystemGameRequest) XAuthorization(xAuthorization string) ApiUnapproveEcosystemGameRequest {
	r.xAuthorization = &xAuthorization
	return r
}

func (r ApiUnapproveEcosystemGameRequest) Execute() (*http.Response, error) {
	return r.ApiService.UnapproveEcosystemGameExecute(r)
}

/*
UnapproveEcosystemGame Unapprove ecosystem game

Unapproves a game for an ecosystem. The game will no longer be able to allow profiles from the ecosystem to login. All profile permissions approved for the game will also be revoked.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ecosystemId The ecosystem id of the authenticating ecosystem.
 @param gameId Any game id within the MetaFab platform.
 @return ApiUnapproveEcosystemGameRequest
*/
func (a *EcosystemsApiService) UnapproveEcosystemGame(ctx context.Context, ecosystemId string, gameId string) ApiUnapproveEcosystemGameRequest {
	return ApiUnapproveEcosystemGameRequest{
		ApiService: a,
		ctx: ctx,
		ecosystemId: ecosystemId,
		gameId: gameId,
	}
}

// Execute executes the request
func (a *EcosystemsApiService) UnapproveEcosystemGameExecute(r ApiUnapproveEcosystemGameRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcosystemsApiService.UnapproveEcosystemGame")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/ecosystems/{ecosystemId}/games/{gameId}"
	localVarPath = strings.Replace(localVarPath, "{"+"ecosystemId"+"}", url.PathEscape(parameterToString(r.ecosystemId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"gameId"+"}", url.PathEscape(parameterToString(r.gameId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthorization == nil {
		return nil, reportError("xAuthorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-Authorization"] = parameterToString(*r.xAuthorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateEcosystemRequest struct {
	ctx context.Context
	ApiService *EcosystemsApiService
	ecosystemId string
	xAuthorization *string
	updateEcosystemRequest *UpdateEcosystemRequest
}

// The &#x60;secretKey&#x60; of the authenticating ecosystem.
func (r ApiUpdateEcosystemRequest) XAuthorization(xAuthorization string) ApiUpdateEcosystemRequest {
	r.xAuthorization = &xAuthorization
	return r
}

func (r ApiUpdateEcosystemRequest) UpdateEcosystemRequest(updateEcosystemRequest UpdateEcosystemRequest) ApiUpdateEcosystemRequest {
	r.updateEcosystemRequest = &updateEcosystemRequest
	return r
}

func (r ApiUpdateEcosystemRequest) Execute() (*EcosystemModel, *http.Response, error) {
	return r.ApiService.UpdateEcosystemExecute(r)
}

/*
UpdateEcosystem Update ecosystem

Update various fields specific to an ecosystem. Such as changing its password, resetting its published or secret key, or updating its approved games.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ecosystemId The ecosystem id of the authenticating ecosystem.
 @return ApiUpdateEcosystemRequest
*/
func (a *EcosystemsApiService) UpdateEcosystem(ctx context.Context, ecosystemId string) ApiUpdateEcosystemRequest {
	return ApiUpdateEcosystemRequest{
		ApiService: a,
		ctx: ctx,
		ecosystemId: ecosystemId,
	}
}

// Execute executes the request
//  @return EcosystemModel
func (a *EcosystemsApiService) UpdateEcosystemExecute(r ApiUpdateEcosystemRequest) (*EcosystemModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EcosystemModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcosystemsApiService.UpdateEcosystem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/ecosystems/{ecosystemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"ecosystemId"+"}", url.PathEscape(parameterToString(r.ecosystemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthorization == nil {
		return localVarReturnValue, nil, reportError("xAuthorization is required and must be specified")
	}
	if r.updateEcosystemRequest == nil {
		return localVarReturnValue, nil, reportError("updateEcosystemRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-Authorization"] = parameterToString(*r.xAuthorization, "")
	// body params
	localVarPostBody = r.updateEcosystemRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateProfileRequest struct {
	ctx context.Context
	ApiService *EcosystemsApiService
	profileId string
	xAuthorization *string
	updateProfileRequest *UpdateProfileRequest
}

// The &#x60;accessToken&#x60; of the authenticating profile.
func (r ApiUpdateProfileRequest) XAuthorization(xAuthorization string) ApiUpdateProfileRequest {
	r.xAuthorization = &xAuthorization
	return r
}

func (r ApiUpdateProfileRequest) UpdateProfileRequest(updateProfileRequest UpdateProfileRequest) ApiUpdateProfileRequest {
	r.updateProfileRequest = &updateProfileRequest
	return r
}

func (r ApiUpdateProfileRequest) Execute() (*ProfileModel, *http.Response, error) {
	return r.ApiService.UpdateProfileExecute(r)
}

/*
UpdateProfile Update profile

Update various fields specific to a profile. Such as changing its password and resetting its access token.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId The profile id of the authenticating profile.
 @return ApiUpdateProfileRequest
*/
func (a *EcosystemsApiService) UpdateProfile(ctx context.Context, profileId string) ApiUpdateProfileRequest {
	return ApiUpdateProfileRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return ProfileModel
func (a *EcosystemsApiService) UpdateProfileExecute(r ApiUpdateProfileRequest) (*ProfileModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProfileModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcosystemsApiService.UpdateProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/profiles/{profileId}"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterToString(r.profileId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthorization == nil {
		return localVarReturnValue, nil, reportError("xAuthorization is required and must be specified")
	}
	if r.updateProfileRequest == nil {
		return localVarReturnValue, nil, reportError("updateProfileRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-Authorization"] = parameterToString(*r.xAuthorization, "")
	// body params
	localVarPostBody = r.updateProfileRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateProfilePlayerRequest struct {
	ctx context.Context
	ApiService *EcosystemsApiService
	profileId string
	gameId string
	playerId string
	xAuthorization *string
	xWalletDecryptKey *string
	updateProfilePlayerRequest *UpdateProfilePlayerRequest
}

// The &#x60;accessToken&#x60; of the authenticating profile.
func (r ApiUpdateProfilePlayerRequest) XAuthorization(xAuthorization string) ApiUpdateProfilePlayerRequest {
	r.xAuthorization = &xAuthorization
	return r
}

// The &#x60;walletDecryptKey&#x60; of the authenticating profile. Required to decrypt and perform blockchain transactions with the profile wallet.
func (r ApiUpdateProfilePlayerRequest) XWalletDecryptKey(xWalletDecryptKey string) ApiUpdateProfilePlayerRequest {
	r.xWalletDecryptKey = &xWalletDecryptKey
	return r
}

func (r ApiUpdateProfilePlayerRequest) UpdateProfilePlayerRequest(updateProfilePlayerRequest UpdateProfilePlayerRequest) ApiUpdateProfilePlayerRequest {
	r.updateProfilePlayerRequest = &updateProfilePlayerRequest
	return r
}

func (r ApiUpdateProfilePlayerRequest) Execute() (*UpdateProfilePlayer200Response, *http.Response, error) {
	return r.ApiService.UpdateProfilePlayerExecute(r)
}

/*
UpdateProfilePlayer Update profile player

Update various fields specific to a player. Such as changing its permissions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId The profile id of the authenticating profile.
 @param gameId Any game id within the MetaFab platform.
 @param playerId Any player id within the MetaFab platform.
 @return ApiUpdateProfilePlayerRequest
*/
func (a *EcosystemsApiService) UpdateProfilePlayer(ctx context.Context, profileId string, gameId string, playerId string) ApiUpdateProfilePlayerRequest {
	return ApiUpdateProfilePlayerRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
		gameId: gameId,
		playerId: playerId,
	}
}

// Execute executes the request
//  @return UpdateProfilePlayer200Response
func (a *EcosystemsApiService) UpdateProfilePlayerExecute(r ApiUpdateProfilePlayerRequest) (*UpdateProfilePlayer200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateProfilePlayer200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcosystemsApiService.UpdateProfilePlayer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/profiles/{profileId}/games/{gameId}/players/{playerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"profileId"+"}", url.PathEscape(parameterToString(r.profileId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"gameId"+"}", url.PathEscape(parameterToString(r.gameId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"playerId"+"}", url.PathEscape(parameterToString(r.playerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthorization == nil {
		return localVarReturnValue, nil, reportError("xAuthorization is required and must be specified")
	}
	if r.xWalletDecryptKey == nil {
		return localVarReturnValue, nil, reportError("xWalletDecryptKey is required and must be specified")
	}
	if r.updateProfilePlayerRequest == nil {
		return localVarReturnValue, nil, reportError("updateProfilePlayerRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-Authorization"] = parameterToString(*r.xAuthorization, "")
	localVarHeaderParams["X-Wallet-Decrypt-Key"] = parameterToString(*r.xWalletDecryptKey, "")
	// body params
	localVarPostBody = r.updateProfilePlayerRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
