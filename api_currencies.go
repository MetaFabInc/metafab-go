/*
MetaFab API

 Complete MetaFab API references and guides can be found at: https://trymetafab.com

API version: 1.4.1
Contact: metafabproject@gmail.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package metafab

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// CurrenciesApiService CurrenciesApi service
type CurrenciesApiService service

type ApiBatchTransferCurrencyRequest struct {
	ctx context.Context
	ApiService *CurrenciesApiService
	currencyId string
	xAuthorization *string
	xPassword *string
	batchTransferCurrencyRequest *BatchTransferCurrencyRequest
}

// The &#x60;secretKey&#x60; of a specific game or the &#x60;accessToken&#x60; of a specific player.
func (r ApiBatchTransferCurrencyRequest) XAuthorization(xAuthorization string) ApiBatchTransferCurrencyRequest {
	r.xAuthorization = &xAuthorization
	return r
}

// The password of the authenticating game or player. Required to decrypt and perform blockchain transactions with the game or player primary wallet.
func (r ApiBatchTransferCurrencyRequest) XPassword(xPassword string) ApiBatchTransferCurrencyRequest {
	r.xPassword = &xPassword
	return r
}

func (r ApiBatchTransferCurrencyRequest) BatchTransferCurrencyRequest(batchTransferCurrencyRequest BatchTransferCurrencyRequest) ApiBatchTransferCurrencyRequest {
	r.batchTransferCurrencyRequest = &batchTransferCurrencyRequest
	return r
}

func (r ApiBatchTransferCurrencyRequest) Execute() (*TransactionModel, *http.Response, error) {
	return r.ApiService.BatchTransferCurrencyExecute(r)
}

/*
BatchTransferCurrency Batch transfer currency

Transfers multiple amounts of currency to multiple provided wallet addresses or wallet addresses associated with the provided walletIds. You may also provide a combination of addresses and walletIds in one request, the proper receipients will be automatically determined, with `addresses` getting `amounts` order priority first.

Optional references may be included for the transfer. References are useful for identifying transfers intended to pay for items, trades, services and more.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param currencyId Any currency id within the MetaFab ecosystem.
 @return ApiBatchTransferCurrencyRequest
*/
func (a *CurrenciesApiService) BatchTransferCurrency(ctx context.Context, currencyId string) ApiBatchTransferCurrencyRequest {
	return ApiBatchTransferCurrencyRequest{
		ApiService: a,
		ctx: ctx,
		currencyId: currencyId,
	}
}

// Execute executes the request
//  @return TransactionModel
func (a *CurrenciesApiService) BatchTransferCurrencyExecute(r ApiBatchTransferCurrencyRequest) (*TransactionModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurrenciesApiService.BatchTransferCurrency")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/currencies/{currencyId}/batchTransfers"
	localVarPath = strings.Replace(localVarPath, "{"+"currencyId"+"}", url.PathEscape(parameterToString(r.currencyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthorization == nil {
		return localVarReturnValue, nil, reportError("xAuthorization is required and must be specified")
	}
	if r.xPassword == nil {
		return localVarReturnValue, nil, reportError("xPassword is required and must be specified")
	}
	if r.batchTransferCurrencyRequest == nil {
		return localVarReturnValue, nil, reportError("batchTransferCurrencyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-Authorization"] = parameterToString(*r.xAuthorization, "")
	localVarHeaderParams["X-Password"] = parameterToString(*r.xPassword, "")
	// body params
	localVarPostBody = r.batchTransferCurrencyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBurnCurrencyRequest struct {
	ctx context.Context
	ApiService *CurrenciesApiService
	currencyId string
	xAuthorization *string
	xPassword *string
	burnCurrencyRequest *BurnCurrencyRequest
}

// The &#x60;secretKey&#x60; of a specific game or the &#x60;accessToken&#x60; of a specific player.
func (r ApiBurnCurrencyRequest) XAuthorization(xAuthorization string) ApiBurnCurrencyRequest {
	r.xAuthorization = &xAuthorization
	return r
}

// The password of the authenticating game or player. Required to decrypt and perform blockchain transactions with the game or player primary wallet.
func (r ApiBurnCurrencyRequest) XPassword(xPassword string) ApiBurnCurrencyRequest {
	r.xPassword = &xPassword
	return r
}

func (r ApiBurnCurrencyRequest) BurnCurrencyRequest(burnCurrencyRequest BurnCurrencyRequest) ApiBurnCurrencyRequest {
	r.burnCurrencyRequest = &burnCurrencyRequest
	return r
}

func (r ApiBurnCurrencyRequest) Execute() (*TransactionModel, *http.Response, error) {
	return r.ApiService.BurnCurrencyExecute(r)
}

/*
BurnCurrency Burn currency

Removes (burns) the provided amount of currency from the authenticating game or players wallet. The currency amount is permanently removed from the circulating supply of the currency.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param currencyId Any currency id within the MetaFab ecosystem.
 @return ApiBurnCurrencyRequest
*/
func (a *CurrenciesApiService) BurnCurrency(ctx context.Context, currencyId string) ApiBurnCurrencyRequest {
	return ApiBurnCurrencyRequest{
		ApiService: a,
		ctx: ctx,
		currencyId: currencyId,
	}
}

// Execute executes the request
//  @return TransactionModel
func (a *CurrenciesApiService) BurnCurrencyExecute(r ApiBurnCurrencyRequest) (*TransactionModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurrenciesApiService.BurnCurrency")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/currencies/{currencyId}/burns"
	localVarPath = strings.Replace(localVarPath, "{"+"currencyId"+"}", url.PathEscape(parameterToString(r.currencyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthorization == nil {
		return localVarReturnValue, nil, reportError("xAuthorization is required and must be specified")
	}
	if r.xPassword == nil {
		return localVarReturnValue, nil, reportError("xPassword is required and must be specified")
	}
	if r.burnCurrencyRequest == nil {
		return localVarReturnValue, nil, reportError("burnCurrencyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-Authorization"] = parameterToString(*r.xAuthorization, "")
	localVarHeaderParams["X-Password"] = parameterToString(*r.xPassword, "")
	// body params
	localVarPostBody = r.burnCurrencyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCurrencyRequest struct {
	ctx context.Context
	ApiService *CurrenciesApiService
	xAuthorization *string
	xPassword *string
	createCurrencyRequest *CreateCurrencyRequest
}

// The &#x60;secretKey&#x60; of the authenticating game.
func (r ApiCreateCurrencyRequest) XAuthorization(xAuthorization string) ApiCreateCurrencyRequest {
	r.xAuthorization = &xAuthorization
	return r
}

// The password of the authenticating game. Required to decrypt and perform blockchain transactions with the game primary wallet.
func (r ApiCreateCurrencyRequest) XPassword(xPassword string) ApiCreateCurrencyRequest {
	r.xPassword = &xPassword
	return r
}

func (r ApiCreateCurrencyRequest) CreateCurrencyRequest(createCurrencyRequest CreateCurrencyRequest) ApiCreateCurrencyRequest {
	r.createCurrencyRequest = &createCurrencyRequest
	return r
}

func (r ApiCreateCurrencyRequest) Execute() (*CreateCurrency200Response, *http.Response, error) {
	return r.ApiService.CreateCurrencyExecute(r)
}

/*
CreateCurrency Create currency

Creates a new game currency and deploys an ERC20 token contract on behalf of the authenticating game's primary wallet. The deployed ERC20 contract is preconfigured to fully support bridging across blockchains, batched transfers and gasless transactions on any supported blockchain as well as full support for gasless transactions from player managed wallets.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateCurrencyRequest
*/
func (a *CurrenciesApiService) CreateCurrency(ctx context.Context) ApiCreateCurrencyRequest {
	return ApiCreateCurrencyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateCurrency200Response
func (a *CurrenciesApiService) CreateCurrencyExecute(r ApiCreateCurrencyRequest) (*CreateCurrency200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateCurrency200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurrenciesApiService.CreateCurrency")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/currencies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthorization == nil {
		return localVarReturnValue, nil, reportError("xAuthorization is required and must be specified")
	}
	if r.xPassword == nil {
		return localVarReturnValue, nil, reportError("xPassword is required and must be specified")
	}
	if r.createCurrencyRequest == nil {
		return localVarReturnValue, nil, reportError("createCurrencyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-Authorization"] = parameterToString(*r.xAuthorization, "")
	localVarHeaderParams["X-Password"] = parameterToString(*r.xPassword, "")
	// body params
	localVarPostBody = r.createCurrencyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCurrenciesRequest struct {
	ctx context.Context
	ApiService *CurrenciesApiService
	xGameKey *string
}

// The &#x60;publishedKey&#x60; of a specific game. This can be shared or included in game clients, websites, etc.
func (r ApiGetCurrenciesRequest) XGameKey(xGameKey string) ApiGetCurrenciesRequest {
	r.xGameKey = &xGameKey
	return r
}

func (r ApiGetCurrenciesRequest) Execute() ([]GetCurrencies200ResponseInner, *http.Response, error) {
	return r.ApiService.GetCurrenciesExecute(r)
}

/*
GetCurrencies Get currencies

Returns an array of active currencies for the game associated with the provided `X-Game-Key`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCurrenciesRequest
*/
func (a *CurrenciesApiService) GetCurrencies(ctx context.Context) ApiGetCurrenciesRequest {
	return ApiGetCurrenciesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetCurrencies200ResponseInner
func (a *CurrenciesApiService) GetCurrenciesExecute(r ApiGetCurrenciesRequest) ([]GetCurrencies200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetCurrencies200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurrenciesApiService.GetCurrencies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/currencies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xGameKey == nil {
		return localVarReturnValue, nil, reportError("xGameKey is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-Game-Key"] = parameterToString(*r.xGameKey, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCurrencyBalanceRequest struct {
	ctx context.Context
	ApiService *CurrenciesApiService
	currencyId string
	address *string
	walletId *string
}

// A valid EVM based address. For example, &#x60;0x39cb70F972E0EE920088AeF97Dbe5c6251a9c25D&#x60;.
func (r ApiGetCurrencyBalanceRequest) Address(address string) ApiGetCurrencyBalanceRequest {
	r.address = &address
	return r
}

// Any wallet id within the MetaFab ecosystem.
func (r ApiGetCurrencyBalanceRequest) WalletId(walletId string) ApiGetCurrencyBalanceRequest {
	r.walletId = &walletId
	return r
}

func (r ApiGetCurrencyBalanceRequest) Execute() (float32, *http.Response, error) {
	return r.ApiService.GetCurrencyBalanceExecute(r)
}

/*
GetCurrencyBalance Get currency balance

Returns the current currency balance of the provided wallet address or or the wallet address associated with the provided walletId.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param currencyId Any currency id within the MetaFab ecosystem.
 @return ApiGetCurrencyBalanceRequest
*/
func (a *CurrenciesApiService) GetCurrencyBalance(ctx context.Context, currencyId string) ApiGetCurrencyBalanceRequest {
	return ApiGetCurrencyBalanceRequest{
		ApiService: a,
		ctx: ctx,
		currencyId: currencyId,
	}
}

// Execute executes the request
//  @return float32
func (a *CurrenciesApiService) GetCurrencyBalanceExecute(r ApiGetCurrencyBalanceRequest) (float32, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  float32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurrenciesApiService.GetCurrencyBalance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/currencies/{currencyId}/balances"
	localVarPath = strings.Replace(localVarPath, "{"+"currencyId"+"}", url.PathEscape(parameterToString(r.currencyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.address != nil {
		localVarQueryParams.Add("address", parameterToString(*r.address, ""))
	}
	if r.walletId != nil {
		localVarQueryParams.Add("walletId", parameterToString(*r.walletId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCurrencyFeesRequest struct {
	ctx context.Context
	ApiService *CurrenciesApiService
	currencyId string
}

func (r ApiGetCurrencyFeesRequest) Execute() (*GetCurrencyFees200Response, *http.Response, error) {
	return r.ApiService.GetCurrencyFeesExecute(r)
}

/*
GetCurrencyFees Get currency fees

Returns the current fee recipient address and fees of the currency for the provided currencyId. Fees are only applicable for gasless transactions performed by default by players.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param currencyId Any currency id within the MetaFab ecosystem.
 @return ApiGetCurrencyFeesRequest
*/
func (a *CurrenciesApiService) GetCurrencyFees(ctx context.Context, currencyId string) ApiGetCurrencyFeesRequest {
	return ApiGetCurrencyFeesRequest{
		ApiService: a,
		ctx: ctx,
		currencyId: currencyId,
	}
}

// Execute executes the request
//  @return GetCurrencyFees200Response
func (a *CurrenciesApiService) GetCurrencyFeesExecute(r ApiGetCurrencyFeesRequest) (*GetCurrencyFees200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCurrencyFees200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurrenciesApiService.GetCurrencyFees")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/currencies/{currencyId}/fees"
	localVarPath = strings.Replace(localVarPath, "{"+"currencyId"+"}", url.PathEscape(parameterToString(r.currencyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCurrencyRoleRequest struct {
	ctx context.Context
	ApiService *CurrenciesApiService
	currencyId string
	role *string
	address *string
	walletId *string
}

// A valid MetaFab role or bytes string representing a role, such as &#x60;0xc9eb32e43bf5ecbceacf00b32281dfc5d6d700a0db676ea26ccf938a385ac3b7&#x60;
func (r ApiGetCurrencyRoleRequest) Role(role string) ApiGetCurrencyRoleRequest {
	r.role = &role
	return r
}

// A valid EVM based address. For example, &#x60;0x39cb70F972E0EE920088AeF97Dbe5c6251a9c25D&#x60;.
func (r ApiGetCurrencyRoleRequest) Address(address string) ApiGetCurrencyRoleRequest {
	r.address = &address
	return r
}

// Any wallet id within the MetaFab ecosystem.
func (r ApiGetCurrencyRoleRequest) WalletId(walletId string) ApiGetCurrencyRoleRequest {
	r.walletId = &walletId
	return r
}

func (r ApiGetCurrencyRoleRequest) Execute() (bool, *http.Response, error) {
	return r.ApiService.GetCurrencyRoleExecute(r)
}

/*
GetCurrencyRole Get currency role

Returns a boolean (true/false) representing if the provided role for this currency has been granted to the provided address or address associated with the provided walletId.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param currencyId Any currency id within the MetaFab ecosystem.
 @return ApiGetCurrencyRoleRequest
*/
func (a *CurrenciesApiService) GetCurrencyRole(ctx context.Context, currencyId string) ApiGetCurrencyRoleRequest {
	return ApiGetCurrencyRoleRequest{
		ApiService: a,
		ctx: ctx,
		currencyId: currencyId,
	}
}

// Execute executes the request
//  @return bool
func (a *CurrenciesApiService) GetCurrencyRoleExecute(r ApiGetCurrencyRoleRequest) (bool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurrenciesApiService.GetCurrencyRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/currencies/{currencyId}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"currencyId"+"}", url.PathEscape(parameterToString(r.currencyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.role == nil {
		return localVarReturnValue, nil, reportError("role is required and must be specified")
	}

	localVarQueryParams.Add("role", parameterToString(*r.role, ""))
	if r.address != nil {
		localVarQueryParams.Add("address", parameterToString(*r.address, ""))
	}
	if r.walletId != nil {
		localVarQueryParams.Add("walletId", parameterToString(*r.walletId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGrantCurrencyRoleRequest struct {
	ctx context.Context
	ApiService *CurrenciesApiService
	currencyId string
	xAuthorization *string
	xPassword *string
	grantCurrencyRoleRequest *GrantCurrencyRoleRequest
}

// The &#x60;secretKey&#x60; of a specific game or the &#x60;accessToken&#x60; of a specific player.
func (r ApiGrantCurrencyRoleRequest) XAuthorization(xAuthorization string) ApiGrantCurrencyRoleRequest {
	r.xAuthorization = &xAuthorization
	return r
}

// The password of the authenticating game or player. Required to decrypt and perform blockchain transactions with the game or player primary wallet.
func (r ApiGrantCurrencyRoleRequest) XPassword(xPassword string) ApiGrantCurrencyRoleRequest {
	r.xPassword = &xPassword
	return r
}

func (r ApiGrantCurrencyRoleRequest) GrantCurrencyRoleRequest(grantCurrencyRoleRequest GrantCurrencyRoleRequest) ApiGrantCurrencyRoleRequest {
	r.grantCurrencyRoleRequest = &grantCurrencyRoleRequest
	return r
}

func (r ApiGrantCurrencyRoleRequest) Execute() (*TransactionModel, *http.Response, error) {
	return r.ApiService.GrantCurrencyRoleExecute(r)
}

/*
GrantCurrencyRole Grant currency role

Grants the provided role for the currency to the provided address or address associated with the provided walletId. Granted roles give different types of authority on behalf of the currency for specific players, addresses, or contracts to perform different types of permissioned currency operations.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param currencyId Any currency id within the MetaFab ecosystem.
 @return ApiGrantCurrencyRoleRequest
*/
func (a *CurrenciesApiService) GrantCurrencyRole(ctx context.Context, currencyId string) ApiGrantCurrencyRoleRequest {
	return ApiGrantCurrencyRoleRequest{
		ApiService: a,
		ctx: ctx,
		currencyId: currencyId,
	}
}

// Execute executes the request
//  @return TransactionModel
func (a *CurrenciesApiService) GrantCurrencyRoleExecute(r ApiGrantCurrencyRoleRequest) (*TransactionModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurrenciesApiService.GrantCurrencyRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/currencies/{currencyId}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"currencyId"+"}", url.PathEscape(parameterToString(r.currencyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthorization == nil {
		return localVarReturnValue, nil, reportError("xAuthorization is required and must be specified")
	}
	if r.xPassword == nil {
		return localVarReturnValue, nil, reportError("xPassword is required and must be specified")
	}
	if r.grantCurrencyRoleRequest == nil {
		return localVarReturnValue, nil, reportError("grantCurrencyRoleRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-Authorization"] = parameterToString(*r.xAuthorization, "")
	localVarHeaderParams["X-Password"] = parameterToString(*r.xPassword, "")
	// body params
	localVarPostBody = r.grantCurrencyRoleRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMintCurrencyRequest struct {
	ctx context.Context
	ApiService *CurrenciesApiService
	currencyId string
	xAuthorization *string
	xPassword *string
	mintCurrencyRequest *MintCurrencyRequest
}

// The &#x60;secretKey&#x60; of the authenticating game.
func (r ApiMintCurrencyRequest) XAuthorization(xAuthorization string) ApiMintCurrencyRequest {
	r.xAuthorization = &xAuthorization
	return r
}

// The password of the authenticating game. Required to decrypt and perform blockchain transactions with the game primary wallet.
func (r ApiMintCurrencyRequest) XPassword(xPassword string) ApiMintCurrencyRequest {
	r.xPassword = &xPassword
	return r
}

func (r ApiMintCurrencyRequest) MintCurrencyRequest(mintCurrencyRequest MintCurrencyRequest) ApiMintCurrencyRequest {
	r.mintCurrencyRequest = &mintCurrencyRequest
	return r
}

func (r ApiMintCurrencyRequest) Execute() (*TransactionModel, *http.Response, error) {
	return r.ApiService.MintCurrencyExecute(r)
}

/*
MintCurrency Mint currency

Creates (mints) the provided amount of currency to the provided wallet address or wallet address associated with the provided walletId.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param currencyId Any currency id within the MetaFab ecosystem.
 @return ApiMintCurrencyRequest
*/
func (a *CurrenciesApiService) MintCurrency(ctx context.Context, currencyId string) ApiMintCurrencyRequest {
	return ApiMintCurrencyRequest{
		ApiService: a,
		ctx: ctx,
		currencyId: currencyId,
	}
}

// Execute executes the request
//  @return TransactionModel
func (a *CurrenciesApiService) MintCurrencyExecute(r ApiMintCurrencyRequest) (*TransactionModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurrenciesApiService.MintCurrency")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/currencies/{currencyId}/mints"
	localVarPath = strings.Replace(localVarPath, "{"+"currencyId"+"}", url.PathEscape(parameterToString(r.currencyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthorization == nil {
		return localVarReturnValue, nil, reportError("xAuthorization is required and must be specified")
	}
	if r.xPassword == nil {
		return localVarReturnValue, nil, reportError("xPassword is required and must be specified")
	}
	if r.mintCurrencyRequest == nil {
		return localVarReturnValue, nil, reportError("mintCurrencyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-Authorization"] = parameterToString(*r.xAuthorization, "")
	localVarHeaderParams["X-Password"] = parameterToString(*r.xPassword, "")
	// body params
	localVarPostBody = r.mintCurrencyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRevokeCurrencyRoleRequest struct {
	ctx context.Context
	ApiService *CurrenciesApiService
	currencyId string
	xAuthorization *string
	xPassword *string
	revokeCollectionRoleRequest *RevokeCollectionRoleRequest
}

// The &#x60;secretKey&#x60; of a specific game or the &#x60;accessToken&#x60; of a specific player.
func (r ApiRevokeCurrencyRoleRequest) XAuthorization(xAuthorization string) ApiRevokeCurrencyRoleRequest {
	r.xAuthorization = &xAuthorization
	return r
}

// The password of the authenticating game or player. Required to decrypt and perform blockchain transactions with the game or player primary wallet.
func (r ApiRevokeCurrencyRoleRequest) XPassword(xPassword string) ApiRevokeCurrencyRoleRequest {
	r.xPassword = &xPassword
	return r
}

func (r ApiRevokeCurrencyRoleRequest) RevokeCollectionRoleRequest(revokeCollectionRoleRequest RevokeCollectionRoleRequest) ApiRevokeCurrencyRoleRequest {
	r.revokeCollectionRoleRequest = &revokeCollectionRoleRequest
	return r
}

func (r ApiRevokeCurrencyRoleRequest) Execute() (*TransactionModel, *http.Response, error) {
	return r.ApiService.RevokeCurrencyRoleExecute(r)
}

/*
RevokeCurrencyRole Revoke currency role

Revokes the provided role for the currency to the provided address or address associated with the provided walletId.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param currencyId Any currency id within the MetaFab ecosystem.
 @return ApiRevokeCurrencyRoleRequest
*/
func (a *CurrenciesApiService) RevokeCurrencyRole(ctx context.Context, currencyId string) ApiRevokeCurrencyRoleRequest {
	return ApiRevokeCurrencyRoleRequest{
		ApiService: a,
		ctx: ctx,
		currencyId: currencyId,
	}
}

// Execute executes the request
//  @return TransactionModel
func (a *CurrenciesApiService) RevokeCurrencyRoleExecute(r ApiRevokeCurrencyRoleRequest) (*TransactionModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurrenciesApiService.RevokeCurrencyRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/currencies/{currencyId}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"currencyId"+"}", url.PathEscape(parameterToString(r.currencyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthorization == nil {
		return localVarReturnValue, nil, reportError("xAuthorization is required and must be specified")
	}
	if r.xPassword == nil {
		return localVarReturnValue, nil, reportError("xPassword is required and must be specified")
	}
	if r.revokeCollectionRoleRequest == nil {
		return localVarReturnValue, nil, reportError("revokeCollectionRoleRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-Authorization"] = parameterToString(*r.xAuthorization, "")
	localVarHeaderParams["X-Password"] = parameterToString(*r.xPassword, "")
	// body params
	localVarPostBody = r.revokeCollectionRoleRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetCurrencyFeesRequest struct {
	ctx context.Context
	ApiService *CurrenciesApiService
	currencyId string
	xAuthorization *string
	xPassword *string
	setCurrencyFeesRequest *SetCurrencyFeesRequest
}

// The &#x60;secretKey&#x60; of the authenticating game.
func (r ApiSetCurrencyFeesRequest) XAuthorization(xAuthorization string) ApiSetCurrencyFeesRequest {
	r.xAuthorization = &xAuthorization
	return r
}

// The password of the authenticating game. Required to decrypt and perform blockchain transactions with the game primary wallet.
func (r ApiSetCurrencyFeesRequest) XPassword(xPassword string) ApiSetCurrencyFeesRequest {
	r.xPassword = &xPassword
	return r
}

func (r ApiSetCurrencyFeesRequest) SetCurrencyFeesRequest(setCurrencyFeesRequest SetCurrencyFeesRequest) ApiSetCurrencyFeesRequest {
	r.setCurrencyFeesRequest = &setCurrencyFeesRequest
	return r
}

func (r ApiSetCurrencyFeesRequest) Execute() (*TransactionModel, *http.Response, error) {
	return r.ApiService.SetCurrencyFeesExecute(r)
}

/*
SetCurrencyFees Set currency fees

Sets the recipient address, basis points, fixed amount and cap amount for a currency's fees.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param currencyId Any currency id within the MetaFab ecosystem.
 @return ApiSetCurrencyFeesRequest
*/
func (a *CurrenciesApiService) SetCurrencyFees(ctx context.Context, currencyId string) ApiSetCurrencyFeesRequest {
	return ApiSetCurrencyFeesRequest{
		ApiService: a,
		ctx: ctx,
		currencyId: currencyId,
	}
}

// Execute executes the request
//  @return TransactionModel
func (a *CurrenciesApiService) SetCurrencyFeesExecute(r ApiSetCurrencyFeesRequest) (*TransactionModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurrenciesApiService.SetCurrencyFees")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/currencies/{currencyId}/fees"
	localVarPath = strings.Replace(localVarPath, "{"+"currencyId"+"}", url.PathEscape(parameterToString(r.currencyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthorization == nil {
		return localVarReturnValue, nil, reportError("xAuthorization is required and must be specified")
	}
	if r.xPassword == nil {
		return localVarReturnValue, nil, reportError("xPassword is required and must be specified")
	}
	if r.setCurrencyFeesRequest == nil {
		return localVarReturnValue, nil, reportError("setCurrencyFeesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-Authorization"] = parameterToString(*r.xAuthorization, "")
	localVarHeaderParams["X-Password"] = parameterToString(*r.xPassword, "")
	// body params
	localVarPostBody = r.setCurrencyFeesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTransferCurrencyRequest struct {
	ctx context.Context
	ApiService *CurrenciesApiService
	currencyId string
	xAuthorization *string
	xPassword *string
	transferCurrencyRequest *TransferCurrencyRequest
}

// The &#x60;secretKey&#x60; of a specific game or the &#x60;accessToken&#x60; of a specific player.
func (r ApiTransferCurrencyRequest) XAuthorization(xAuthorization string) ApiTransferCurrencyRequest {
	r.xAuthorization = &xAuthorization
	return r
}

// The password of the authenticating game or player. Required to decrypt and perform blockchain transactions with the game or player primary wallet.
func (r ApiTransferCurrencyRequest) XPassword(xPassword string) ApiTransferCurrencyRequest {
	r.xPassword = &xPassword
	return r
}

func (r ApiTransferCurrencyRequest) TransferCurrencyRequest(transferCurrencyRequest TransferCurrencyRequest) ApiTransferCurrencyRequest {
	r.transferCurrencyRequest = &transferCurrencyRequest
	return r
}

func (r ApiTransferCurrencyRequest) Execute() (*TransactionModel, *http.Response, error) {
	return r.ApiService.TransferCurrencyExecute(r)
}

/*
TransferCurrency Transfer currency

Transfers an amount of currency to the provided wallet address or wallet address associated with the provided walletId. If you want to transfer to multiple wallets with different amounts and optional references in one API request, please see the Batch transfer currency documentation.

An optional reference may be included for the transfer. References are useful for identifying transfers intended to pay for items, trades, services and more.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param currencyId Any currency id within the MetaFab ecosystem.
 @return ApiTransferCurrencyRequest
*/
func (a *CurrenciesApiService) TransferCurrency(ctx context.Context, currencyId string) ApiTransferCurrencyRequest {
	return ApiTransferCurrencyRequest{
		ApiService: a,
		ctx: ctx,
		currencyId: currencyId,
	}
}

// Execute executes the request
//  @return TransactionModel
func (a *CurrenciesApiService) TransferCurrencyExecute(r ApiTransferCurrencyRequest) (*TransactionModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurrenciesApiService.TransferCurrency")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/currencies/{currencyId}/transfers"
	localVarPath = strings.Replace(localVarPath, "{"+"currencyId"+"}", url.PathEscape(parameterToString(r.currencyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthorization == nil {
		return localVarReturnValue, nil, reportError("xAuthorization is required and must be specified")
	}
	if r.xPassword == nil {
		return localVarReturnValue, nil, reportError("xPassword is required and must be specified")
	}
	if r.transferCurrencyRequest == nil {
		return localVarReturnValue, nil, reportError("transferCurrencyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-Authorization"] = parameterToString(*r.xAuthorization, "")
	localVarHeaderParams["X-Password"] = parameterToString(*r.xPassword, "")
	// body params
	localVarPostBody = r.transferCurrencyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
